{"version":3,"file":"1.js","sources":["../src/values/Path.ts","../src/values/StreamValue.ts","../src/values/dateHelpers.ts","../src/values/utils.ts","../src/evaluator/equality.ts","../src/evaluator/matching.ts","../src/evaluator/ordering.ts","../src/evaluator/operators.ts","../src/evaluator/scope.ts","../src/evaluator/evaluate.ts","../src/evaluator/constantEvaluate.ts","../src/evaluator/pt.ts","../src/evaluator/scoring.ts","../src/evaluator/functions.ts","../src/markProcessor.ts","../src/rawParser.js","../src/traversal.ts","../src/parser.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n","import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i')\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n","import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {}\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n    },\n    null\n  )\n  return evaluate(tree, scope)\n}\n","import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n","import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n}\n","import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n"],"names":["escapeRegExp","string","replace","pathRegExp","pattern","re","part","split","push","RegExp","join","Path","constructor","patternRe","matches","str","test","toJSON","StreamValue","generator","type","ticker","isDone","data","isArray","get","result","value","Symbol","asyncIterator","i","length","_nextTick","currentResolver","setupTicker","Promise","resolve","tick","fetch","RFC3339_REGEX","parseRFC3339","Date","formatRFC3339","d","year","addLeadingZero","getUTCFullYear","month","getUTCMonth","day","getUTCDate","hour","getUTCHours","minute","getUTCMinutes","second","getUTCSeconds","fractionalSecond","millis","getMilliseconds","num","targetLength","toString","StaticValue","Array","element","fromJS","Error","NULL_VALUE","TRUE_VALUE","FALSE_VALUE","DateTime","date","parseToValue","equals","other","getTime","add","secs","copy","setTime","difference","compareTo","fromNumber","Number","isFinite","fromString","fromDateTime","dt","fromPath","path","isIterator","obj","next","val","getType","isEqual","a","b","CHARS","CHARS_WITH_WILDCARD","EDGE_CHARS","MAX_TERM_LENGTH","matchText","tokens","patterns","every","matchTokenize","text","match","matchAnalyzePattern","termsRe","matchPatternRegex","map","some","token","terms","term","slice","gatherText","cb","success","TYPE_ORDER","datetime","number","boolean","partialCompare","aType","bType","totalCompare","aTypeOrder","bTypeOrder","operators","eq","left","right","neq","gt","gte","lt","lte","in","inop","concat","didSucceed","matched","plus","minus","numericOperator","Math","pow","impl","Scope","params","source","context","parent","isHidden","createNested","createHidden","evaluate","node","scope","execute","func","EXECUTORS","promiselessApply","then","This","_","Selector","Everything","Parameter","name","Context","key","Parent","n","current","OpCall","op","leftValue","rightValue","Select","alternatives","fallback","alt","altCond","condition","InRange","base","isInclusive","leftCmp","rightCmp","Filter","expr","baseValue","elem","newScope","exprValue","Projection","FuncCall","args","PipeFuncCall","AccessAttribute","hasOwnProperty","AccessElement","index","finalIndex","Slice","array","leftIdx","rightIdx","Deref","id","_ref","doc","_id","Value","Group","Object","attributes","attr","attrType","cond","assign","elements","isSplat","v","Tuple","Or","And","Not","Neg","Pos","Asc","Desc","ArrayCoerce","Map","FlatMap","innerValue","inner","evaluateQuery","tree","options","root","dataset","timestamp","identity","sanity","after","before","canConstantEvaluate","DUMMY_SCOPE","tryConstantEvaluate","constantEvaluate","portableTextContent","blockText","texts","arrayText","block","_type","children","child","BM25k","evaluateScore","evaluateMatchScore","innerScore","boost","leftScore","rightScore","res","score","freq","reduce","c","hasReference","pathSet","has","values","countUTF8","count","code","charCodeAt","_global","anywhere","arity","coalesce","arg","dateTime","defined","references","Set","size","scopeValue","round","prec","precValue","isInteger","toFixed","now","toISOString","lower","toLowerCase","upper","toUpperCase","sep","from","startsWith","prefix","arr","buf","needSep","compact","unique","added","iter","pt","projectId","pipeFunctions","order","mappers","directions","mapper","direction","aux","idx","tuple","sort","aTuple","bTuple","unknown","scored","valueScore","_score","newObject","delta","operation","hasBefore","hasAfter","changedAny","mode","changedOnly","diff","math","min","max","sum","avg","namespaces","global","MarkProcessor","marks","parseOptions","allowBoost","hasMark","pos","getMark","shift","process","visitor","mark","call","processString","processStringEnd","prev","curr","position","len","WS","NUM","IDENT","PREC_PAIR","PREC_OR","PREC_AND","PREC_COMP","PREC_ORDER","PREC_ADD","PREC_SUB","PREC_MUL","PREC_DIV","PREC_MOD","PREC_POW","PREC_POS","PREC_NOT","PREC_NEG","parse","skipWS","parseExpr","failPosition","level","startPos","rhs","parseObject","parseString","identLen","parseRegex","numLen","fracLen","expLen","parseFuncCall","lhsLevel","trav","loop","innerPos","parseTraversal","unshift","nextToken","nextPos","identPos","ident","parseRegexStr","isGroup","rangePos","identStart","nameLen","lastPos","pairPos","indexOf","m","exec","flatMap","traverseArray","build","traversePlain","traverseElement","traverseProjection","ESCAPE_SEQUENCE","f","r","t","expandHex","charCode","parseInt","String","fromCharCode","GroqQueryError","arguments","EXPR_BUILDER","group","p","everything","this","dblparent","traverse","traversalList","TRAVERSE_BUILDER","traversal","this_attr","neg","sub","mul","div","mod","comp","in_range","char","integer","strValue","float","sci","object","OBJECT_BUILDER","members","func_call","namespace","argumentShouldBeSelector","SELECTOR_BUILDER","funcs","validateArity","pipecall","oldAllowBoost","markName","pair","and","or","not","asc","desc","param","object_expr","extractPropertyKey","object_pair","object_splat","object_splat_this","square_bracket","projection","attr_access","deref","wrap","array_postfix","functionName","argCount","functionsRequiringSelectors","includes","GroqSyntaxError","input","rawParse","processor"],"mappings":";;;;;AAAA,SAASA,aAAaC,MAAgB,EAAA;EAC7B,OAAAA,MAAA,CAAOC,OAAQ,CAAA,qBAAA,EAAuB,MAAM,CAAA;AACrD;AAEA,SAASC,WAAWC,OAAiB,EAAA;EACnC,MAAMC,KAAK,EAAC;EACZ,KAAA,MAAWC,IAAQ,IAAAF,OAAA,CAAQG,KAAM,CAAA,GAAG,CAAG,EAAA;IACrC,IAAID,SAAS,GAAK,EAAA;MAChBD,EAAA,CAAGG,KAAK,OAAO,CAAA;IAAA,CACjB,MAAA,IAAWF,SAAS,IAAM,EAAA;MACxBD,EAAA,CAAGG,KAAK,IAAI,CAAA;IAAA,CACP,MAAA;MACFH,EAAA,CAAAG,IAAA,CAAKR,YAAa,CAAAM,IAAI,CAAC,CAAA;IAC5B;EACF;EAEA,OAAO,IAAIG,MAAO,YAAIJ,EAAG,CAAAK,IAAA,CAAK,GAAG,CAAI,OAAA;AACvC;AAEO,MAAMC,IAAK,CAAA;EAIhBC,YAAYR,OAAiB,EAAA;IAC3B,IAAA,CAAKA,OAAU,GAAAA,OAAA;IACV,IAAA,CAAAS,SAAA,GAAYV,WAAWC,OAAO,CAAA;EACrC;EAEAU,QAAQC,GAAsB,EAAA;IACrB,OAAA,IAAA,CAAKF,SAAU,CAAAG,IAAA,CAAKD,GAAG,CAAA;EAChC;EAEAE,MAAiB,GAAA;IACf,OAAO,IAAK,CAAAb,OAAA;EACd;AACF;ACjCO,MAAMc,WAAY,CAAA;EAOvBN,YAAYO,SAAuD,EAAA;IANlD,IAAA,CAAAC,IAAA,GAAA,QAAA;IAOf,IAAA,CAAKD,SAAY,GAAAA,SAAA;IACjB,IAAA,CAAKE,MAAS,GAAA,IAAA;IACd,IAAA,CAAKC,MAAS,GAAA,KAAA;IACd,IAAA,CAAKC,OAAO,EAAC;EACf;EAGAC,OAAmB,GAAA;IACV,OAAA,IAAA;EACT;EAEA,MAAMC,GAAoB,GAAA;IACxB,MAAMC,SAAS,EAAC;IAChB,WAAA,MAAiBC,SAAS,IAAM,EAAA;MAC9BD,MAAA,CAAOlB,IAAK,CAAA,MAAMmB,KAAM,CAAAF,GAAA,EAAK,CAAA;IAC/B;IACO,OAAAC,MAAA;EACT;EAEA,QAAQE,OAAOC,aAAuD,IAAA;IACpE,IAAIC,CAAI,GAAA,CAAA;IACR,OAAO,IAAM,EAAA;MACX,OAAOA,CAAI,GAAA,IAAA,CAAKP,IAAK,CAAAQ,MAAA,EAAQD,CAAK,EAAA,EAAA;QAChC,MAAM,KAAKP,IAAK,CAAAO,CAAA,CAAA;MAClB;MAEA,IAAI,KAAKR,MAAQ,EAAA;QACf;MACF;MAEA,MAAM,KAAKU,SAAU,EAAA;IACvB;EACF;EAEAA,SAA2B,GAAA;IACzB,IAAI,KAAKX,MAAQ,EAAA;MACf,OAAO,IAAK,CAAAA,MAAA;IACd;IAEI,IAAAY,eAAA;IACJ,MAAMC,cAAc,MAAM;MACxB,IAAA,CAAKb,MAAS,GAAA,IAAIc,OAAQ,CAACC,OAAY,IAAA;QACnBH,eAAA,GAAAG,OAAA;MAAA,CACnB,CAAA;IAAA,CACH;IAEA,MAAMC,OAAO,MAAM;MACDJ,eAAA,EAAA;MACJC,WAAA,EAAA;IAAA,CACd;IAEA,MAAMI,QAAQ,YAAY;MACP,WAAA,MAAAX,KAAA,IAAS,IAAK,CAAAR,SAAA,EAAa,EAAA;QACrC,IAAA,CAAAI,IAAA,CAAKf,KAAKmB,KAAK,CAAA;QACfU,IAAA,EAAA;MACP;MAEA,IAAA,CAAKf,MAAS,GAAA,IAAA;MACTe,IAAA,EAAA;IAAA,CACP;IAEYH,WAAA,EAAA;IACNI,KAAA,EAAA;IACN,OAAO,IAAK,CAAAjB,MAAA;EACd;AACF;AC3EA,MAAMkB,aAAgB,GAAA,oEAAA;AAEf,SAASC,aAAazB,GAA0B,EAAA;EACjD,IAAAwB,aAAA,CAAcvB,IAAK,CAAAD,GAAG,CAAG,EAAA;IACpB,OAAA,IAAI0B,KAAK1B,GAAG,CAAA;EACrB;EACO,OAAA,IAAA;AACT;AAEO,SAAS2B,cAAcC,CAAiB,EAAA;EAC7C,MAAMC,IAAO,GAAAC,cAAA,CAAeF,CAAE,CAAAG,cAAA,IAAkB,CAAC,CAAA;EACjD,MAAMC,QAAQF,cAAe,CAAAF,CAAA,CAAEK,WAAY,EAAA,GAAI,GAAG,CAAC,CAAA;EACnD,MAAMC,GAAM,GAAAJ,cAAA,CAAeF,CAAE,CAAAO,UAAA,IAAc,CAAC,CAAA;EAC5C,MAAMC,IAAO,GAAAN,cAAA,CAAeF,CAAE,CAAAS,WAAA,IAAe,CAAC,CAAA;EAC9C,MAAMC,MAAS,GAAAR,cAAA,CAAeF,CAAE,CAAAW,aAAA,IAAiB,CAAC,CAAA;EAClD,MAAMC,MAAS,GAAAV,cAAA,CAAeF,CAAE,CAAAa,aAAA,IAAiB,CAAC,CAAA;EAElD,IAAIC,gBAAmB,GAAA,EAAA;EACjB,MAAAC,MAAA,GAASf,EAAEgB,eAAgB,EAAA;EACjC,IAAID,UAAU,CAAG,EAAA;IACID,gBAAA,cAAIZ,cAAe,CAAAa,MAAA,EAAQ,CAAC,CAAA,CAAA;EACjD;EAEA,iBAAUd,IAAQ,cAAAG,KAAA,cAASE,GAAO,cAAAE,IAAA,cAAQE,oBAAUE,MAAS,SAAAE,gBAAA;AAC/D;AAMA,SAASZ,cAAA,CAAee,KAAeC,YAAsB,EAAA;EACvD,IAAA9C,GAAA,GAAM6C,IAAIE,QAAS,EAAA;EAChB,OAAA/C,GAAA,CAAIgB,SAAS8B,YAAc,EAAA;IAChC9C,GAAA,cAAUA,GAAA,CAAA;EACZ;EACO,OAAAA,GAAA;AACT;AC/BO,MAAMgD,WAAmC,CAAA;EAI9CnD,WAAA,CAAYW,MAASH,IAAS,EAAA;IAC5B,IAAA,CAAKG,IAAO,GAAAA,IAAA;IACZ,IAAA,CAAKH,IAAO,GAAAA,IAAA;EACd;EAEAI,OAAmB,GAAA;IACjB,OAAO,KAAKJ,IAAS,KAAA,OAAA;EACvB;EAGA,MAAMK,GAAoB,GAAA;IACxB,OAAO,IAAK,CAAAF,IAAA;EACd;EAEA,CAACK,OAAOC,aAAkD,IAAA;IACxD,IAAImC,KAAM,CAAAxC,OAAA,CAAQ,IAAK,CAAAD,IAAI,CAAG,EAAA;MAC5B,OAAQ,WAAWA,IAAM,EAAA;QACvB,KAAA,MAAW0C,WAAW1C,IAAM,EAAA;UAC1B,MAAM2C,OAAOD,OAAO,CAAA;QACtB;MAAA,CACF,CAAG,KAAK1C,IAAI,CAAA;IACd;IACA,MAAM,IAAI4C,KAAA,gCAA8B,IAAA,CAAK/C,IAAM,EAAA;EACrD;AACF;AAEO,MAAMgD,UAAwB,GAAA,IAAIL,WAAY,CAAA,IAAA,EAAM,MAAM,CAAA;AAC1D,MAAMM,UAA2B,GAAA,IAAIN,WAAY,CAAA,IAAA,EAAM,SAAS,CAAA;AAChE,MAAMO,WAA4B,GAAA,IAAIP,WAAY,CAAA,KAAA,EAAO,SAAS,CAAA;AAElE,MAAMQ,QAAS,CAAA;EAGpB3D,YAAY4D,IAAY,EAAA;IACtB,IAAA,CAAKA,IAAO,GAAAA,IAAA;EACd;EAEA,OAAOC,aAAa1D,GAAoB,EAAA;IAChC,MAAAyD,IAAA,GAAOhC,aAAazB,GAAG,CAAA;IAC7B,IAAIyD,IAAM,EAAA;MACR,OAAO,IAAIT,WAAY,CAAA,IAAIQ,QAAS,CAAAC,IAAI,GAAG,UAAU,CAAA;IACvD;IACO,OAAAJ,UAAA;EACT;EAEAM,OAAOC,KAA0B,EAAA;IAC/B,OAAO,KAAKH,IAAK,CAAAI,OAAA,EAAa,IAAAD,KAAA,CAAMH,KAAKI,OAAQ,EAAA;EACnD;EAEAC,IAAIC,IAAwB,EAAA;IAC1B,MAAMC,OAAO,IAAItC,IAAA,CAAK,IAAK,CAAA+B,IAAA,CAAKI,SAAS,CAAA;IACzCG,IAAA,CAAKC,OAAQ,CAAAD,IAAA,CAAKH,OAAQ,EAAA,GAAIE,OAAO,GAAI,CAAA;IAClC,OAAA,IAAIP,SAASQ,IAAI,CAAA;EAC1B;EAEAE,WAAWN,KAAyB,EAAA;IAClC,OAAA,CAAQ,KAAKH,IAAK,CAAAI,OAAA,KAAYD,KAAM,CAAAH,IAAA,CAAKI,SAAa,IAAA,GAAA;EACxD;EAEAM,UAAUP,KAAyB,EAAA;IACjC,OAAO,KAAKH,IAAK,CAAAI,OAAA,EAAY,GAAAD,KAAA,CAAMH,KAAKI,OAAQ,EAAA;EAClD;EAEAd,QAAmB,GAAA;IACV,OAAApB,aAAA,CAAc,KAAK8B,IAAI,CAAA;EAChC;EAEAvD,MAAiB,GAAA;IACf,OAAO,KAAK6C,QAAS,EAAA;EACvB;AACF;AAEO,SAASqB,WAAWvB,GAAoB,EAAA;EACzC,IAAAwB,MAAA,CAAOC,QAAS,CAAAzB,GAAG,CAAG,EAAA;IACjB,OAAA,IAAIG,WAAY,CAAAH,GAAA,EAAK,QAAQ,CAAA;EACtC;EACO,OAAAQ,UAAA;AACT;AAEO,SAASkB,WAAWvE,GAAoB,EAAA;EACtC,OAAA,IAAIgD,WAAY,CAAAhD,GAAA,EAAK,QAAQ,CAAA;AACtC;AAEO,SAASwE,aAAaC,EAAqB,EAAA;EACzC,OAAA,IAAIzB,WAAY,CAAAyB,EAAA,EAAI,UAAU,CAAA;AACvC;AAEO,SAASC,SAASC,IAAmB,EAAA;EACnC,OAAA,IAAI3B,WAAY,CAAA2B,IAAA,EAAM,MAAM,CAAA;AACrC;AAEA,SAASC,WAAWC,GAAqB,EAAA;EAChC,OAAAA,GAAA,IAAO,OAAOA,GAAA,CAAIC,IAAS,KAAA,UAAA;AACpC;AAGO,SAAS3B,OAAO4B,GAAiB,EAAA;EAClC,IAAAH,UAAA,CAAWG,GAAG,CAAG,EAAA;IACZ,OAAA,IAAI5E,YAAY,mBAAmB;MACxC,WAAA,MAAiBS,SAASmE,GAAK,EAAA;QAC7B,MAAM5B,OAAOvC,KAAK,CAAA;MACpB;IAAA,CACD,CAAA;EACQ,CAAA,MAAA,IAAAmE,GAAA,KAAQ,IAAQ,IAAAA,GAAA,KAAQ,KAAW,CAAA,EAAA;IACrC,OAAA1B,UAAA;EACT;EACA,OAAO,IAAIL,WAAA,CAAY+B,GAAK,EAAAC,OAAA,CAAQD,GAAG,CAAC,CAAA;AAC1C;AAMO,SAASC,QAAQxE,IAAqB,EAAA;EAC3C,IAAIA,IAAS,KAAA,IAAA,IAAQ,OAAOA,IAAA,KAAS,WAAa,EAAA;IACzC,OAAA,MAAA;EACT;EACI,IAAAyC,KAAA,CAAMxC,OAAQ,CAAAD,IAAI,CAAG,EAAA;IAChB,OAAA,OAAA;EACT;EACA,IAAIA,gBAAgBZ,IAAM,EAAA;IACjB,OAAA,MAAA;EACT;EACA,IAAIY,gBAAgBgD,QAAU,EAAA;IACrB,OAAA,UAAA;EACT;EACA,OAAO,OAAOhD,IAAA;AAChB;ACtIgB,SAAAyE,OAAA,CAAQC,GAAUC,CAAmB,EAAA;EAEhD,IAAAD,CAAA,CAAE7E,SAAS,QAAY,IAAA8E,CAAA,CAAE9E,SAAS,QAClC,IAAA6E,CAAA,CAAE7E,IAAS,KAAA,SAAA,IAAa8E,CAAE,CAAA9E,IAAA,KAAS,aACnC6E,CAAE,CAAA7E,IAAA,KAAS,MAAU,IAAA8E,CAAA,CAAE9E,IAAS,KAAA,MAAA,IAChC6E,EAAE7E,IAAS,KAAA,QAAA,IAAY8E,CAAE,CAAA9E,IAAA,KAAS,QACnC,EAAA;IACO,OAAA6E,CAAA,CAAE1E,SAAS2E,CAAE,CAAA3E,IAAA;EACtB;EAEA,IAAI0E,CAAE,CAAA7E,IAAA,KAAS,UAAc,IAAA8E,CAAA,CAAE9E,SAAS,UAAY,EAAA;IAClD,OAAO6E,CAAE,CAAA1E,IAAA,CAAKmD,MAAO,CAAAwB,CAAA,CAAE3E,IAAI,CAAA;EAC7B;EAEO,OAAA,KAAA;AACT;ACfA,MAAM4E,KAAQ,GAAA,uCAAA;AACd,MAAMC,mBAAsB,GAAA,sCAAA;AAC5B,MAAMC,UAAa,GAAA,gBAAA;AACnB,MAAMC,eAAkB,GAAA,IAAA;AAMR,SAAAC,SAAA,CAAUC,QAAiBC,QAA8B,EAAA;EACvE,IAAID,MAAO,CAAAzE,MAAA,KAAW,CAAK,IAAA0E,QAAA,CAAS1E,WAAW,CAAG,EAAA;IACzC,OAAA,KAAA;EACT;EAEA,OAAO0E,SAASC,KAAM,CAACtG,OAAY,IAAAA,OAAA,CAAQoG,MAAM,CAAC,CAAA;AACpD;AAEO,SAASG,cAAcC,IAAuB,EAAA;EAC5C,OAAAA,IAAA,CAAK1G,QAAQmG,UAAY,EAAA,EAAE,EAAEQ,KAAM,CAAAV,KAAK,KAAK,EAAC;AACvD;AAEO,SAASW,oBAAoBF,IAAyB,EAAA;EACrD,MAAAG,OAAA,GAAUC,kBAAkBJ,IAAI,CAAA;EACtC,OAAOG,OAAQ,CAAAE,GAAA,CAAK5G,EAAA,IAAQmG,MAAoB,IAAAA,MAAA,CAAOU,IAAK,CAACC,KAAU,IAAA9G,EAAA,CAAGW,IAAK,CAAAmG,KAAK,CAAC,CAAC,CAAA;AACxF;AAEO,SAASH,kBAAkBJ,IAAwB,EAAA;EAClD,MAAAQ,KAAA,GAAQR,KAAK1G,OAAQ,CAAAmG,UAAA,EAAY,EAAE,CAAE,CAAAQ,KAAA,CAAMT,mBAAmB,CAAA,IAAK,EAAC;EAC1E,OAAOgB,KAAM,CAAAH,GAAA,CACVI,IAAA,IAAS,IAAI5G,MAAA,YAAW4G,IAAK,CAAAC,KAAA,CAAM,CAAG,EAAAhB,eAAe,CAAE,CAAApG,OAAA,CAAQ,KAAO,EAAA,IAAI,SAAM,GAAG,CAAA,CACtF;AACF;AAEsB,eAAAqH,UAAA,CAAW5F,OAAc6F,EAA6C,EAAA;EACtF,IAAA7F,KAAA,CAAMP,SAAS,QAAU,EAAA;IAC3BoG,EAAA,CAAG7F,MAAMJ,IAAI,CAAA;IACN,OAAA,IAAA;EACT;EAEI,IAAAI,KAAA,CAAMH,SAAW,EAAA;IACnB,IAAIiG,OAAU,GAAA,IAAA;IACd,WAAA,MAAiBnH,QAAQqB,KAAO,EAAA;MAC1B,IAAArB,IAAA,CAAKc,SAAS,QAAU,EAAA;QAC1BoG,EAAA,CAAGlH,KAAKiB,IAAI,CAAA;MAAA,CACP,MAAA;QACKkG,OAAA,GAAA,KAAA;MACZ;IACF;IACO,OAAAA,OAAA;EACT;EAEO,OAAA,KAAA;AACT;ACpDA,MAAMC,UAA2C,GAAA;EAC/CC,QAAU,EAAA,CAAA;EACVC,MAAQ,EAAA,CAAA;EACR3H,MAAQ,EAAA,CAAA;EACR4H,OAAS,EAAA;AACX,CAAA;AAGgB,SAAAC,cAAA,CAAe7B,GAAQC,CAAuB,EAAA;EACtD,MAAA6B,KAAA,GAAQhC,QAAQE,CAAC,CAAA;EACjB,MAAA+B,KAAA,GAAQjC,QAAQG,CAAC,CAAA;EAEvB,IAAI6B,UAAUC,KAAO,EAAA;IACZ,OAAA,IAAA;EACT;EAEQ,QAAAD,KAAA;IACD,KAAA,QAAA;IACA,KAAA,SAAA;MACH,OAAO9B,CAAI,GAAAC,CAAA;IACR,KAAA,QAAA;MACH,IAAID,CAAI,GAAAC,CAAA,EAAU,OAAA,CAAA,CAAA;MAClB,IAAID,CAAI,GAAAC,CAAA,EAAU,OAAA,CAAA;MACX,OAAA,CAAA;IACJ,KAAA,UAAA;MACI,OAAAD,CAAA,CAAEf,UAAUgB,CAAC,CAAA;IAAA;MAEb,OAAA,IAAA;EAAA;AAEb;AAGgB,SAAA+B,YAAA,CAAahC,GAAQC,CAAgB,EAAA;EAC7C,MAAA6B,KAAA,GAAQhC,QAAQE,CAAC,CAAA;EACjB,MAAA+B,KAAA,GAAQjC,QAAQG,CAAC,CAAA;EAEjB,MAAAgC,UAAA,GAAaR,WAAWK,KAAU,CAAA,IAAA,GAAA;EAClC,MAAAI,UAAA,GAAaT,WAAWM,KAAU,CAAA,IAAA,GAAA;EAExC,IAAIE,eAAeC,UAAY,EAAA;IAC7B,OAAOD,UAAa,GAAAC,UAAA;EACtB;EAEI,IAAAzG,MAAA,GAASoG,cAAe,CAAA7B,CAAA,EAAGC,CAAC,CAAA;EAChC,IAAIxE,WAAW,IAAM,EAAA;IACVA,MAAA,GAAA,CAAA;EACX;EACO,OAAAA,MAAA;AACT;AChCO,MAAM0G,SAA+C,GAAA;EAC1D,IAAM,EAAA,SAASC,EAAG,CAAAC,IAAA,EAAMC,KAAO,EAAA;IAC7B,OAAOvC,OAAQ,CAAAsC,IAAA,EAAMC,KAAK,CAAA,GAAIlE,UAAa,GAAAC,WAAA;EAC7C,CAAA;EAEA,IAAM,EAAA,SAASkE,GAAI,CAAAF,IAAA,EAAMC,KAAO,EAAA;IAC9B,OAAOvC,OAAQ,CAAAsC,IAAA,EAAMC,KAAK,CAAA,GAAIjE,WAAc,GAAAD,UAAA;EAC9C,CAAA;EAEA,GAAK,EAAA,SAASoE,EAAG,CAAAH,IAAA,EAAMC,KAAO,EAAA;IAC5B,IAAID,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,IAAS,KAAA,QAAA,EAAiB,OAAAgD,UAAA;IAC9D,MAAM1C,MAAS,GAAAoG,cAAA,CAAeQ,IAAK,CAAA/G,IAAA,EAAMgH,MAAMhH,IAAI,CAAA;IAEnD,IAAIG,WAAW,IAAM,EAAA;MACZ,OAAA0C,UAAA;IACT;IACO,OAAA1C,MAAA,GAAS,IAAI2C,UAAa,GAAAC,WAAA;EACnC,CAAA;EAEA,IAAM,EAAA,SAASoE,GAAI,CAAAJ,IAAA,EAAMC,KAAO,EAAA;IAC9B,IAAID,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,IAAS,KAAA,QAAA,EAAiB,OAAAgD,UAAA;IAC9D,MAAM1C,MAAS,GAAAoG,cAAA,CAAeQ,IAAK,CAAA/G,IAAA,EAAMgH,MAAMhH,IAAI,CAAA;IAEnD,IAAIG,WAAW,IAAM,EAAA;MACZ,OAAA0C,UAAA;IACT;IACO,OAAA1C,MAAA,IAAU,IAAI2C,UAAa,GAAAC,WAAA;EACpC,CAAA;EAEA,GAAK,EAAA,SAASqE,EAAG,CAAAL,IAAA,EAAMC,KAAO,EAAA;IAC5B,IAAID,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,IAAS,KAAA,QAAA,EAAiB,OAAAgD,UAAA;IAC9D,MAAM1C,MAAS,GAAAoG,cAAA,CAAeQ,IAAK,CAAA/G,IAAA,EAAMgH,MAAMhH,IAAI,CAAA;IAEnD,IAAIG,WAAW,IAAM,EAAA;MACZ,OAAA0C,UAAA;IACT;IACO,OAAA1C,MAAA,GAAS,IAAI2C,UAAa,GAAAC,WAAA;EACnC,CAAA;EAEA,IAAM,EAAA,SAASsE,GAAI,CAAAN,IAAA,EAAMC,KAAO,EAAA;IAC9B,IAAID,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,IAAS,KAAA,QAAA,EAAiB,OAAAgD,UAAA;IAC9D,MAAM1C,MAAS,GAAAoG,cAAA,CAAeQ,IAAK,CAAA/G,IAAA,EAAMgH,MAAMhH,IAAI,CAAA;IAEnD,IAAIG,WAAW,IAAM,EAAA;MACZ,OAAA0C,UAAA;IACT;IACO,OAAA1C,MAAA,IAAU,IAAI2C,UAAa,GAAAC,WAAA;EACpC,CAAA;EAGAuE,EAAI,EAAA,eAAeC,IAAK,CAAAR,IAAA,EAAMC,KAAO,EAAA;IAC/B,IAAAA,KAAA,CAAMnH,SAAS,MAAQ,EAAA;MACrB,IAAAkH,IAAA,CAAKlH,SAAS,QAAU,EAAA;QACnB,OAAAgD,UAAA;MACT;MAEA,OAAOmE,MAAMhH,IAAK,CAAAT,OAAA,CAAQwH,IAAK,CAAA/G,IAAI,IAAI8C,UAAa,GAAAC,WAAA;IACtD;IAEI,IAAAiE,KAAA,CAAM/G,SAAW,EAAA;MACnB,WAAA,MAAiB0E,KAAKqC,KAAO,EAAA;QACvB,IAAAvC,OAAA,CAAQsC,IAAM,EAAApC,CAAC,CAAG,EAAA;UACb,OAAA7B,UAAA;QACT;MACF;MAEO,OAAAC,WAAA;IACT;IAEO,OAAAF,UAAA;EACT,CAAA;EAEAyC,KAAO,EAAA,eAAeA,KAAM,CAAAyB,IAAA,EAAMC,KAAO,EAAA;IACvC,IAAI/B,SAAkB,EAAC;IACvB,IAAIC,WAAsB,EAAC;IAErB,MAAAc,UAAA,CAAWe,IAAM,EAAChI,IAAS,IAAA;MAC/BkG,MAAA,GAASA,MAAO,CAAAuC,MAAA,CAAOpC,aAAc,CAAArG,IAAI,CAAC,CAAA;IAAA,CAC3C,CAAA;IAED,MAAM0I,UAAa,GAAA,MAAMzB,UAAW,CAAAgB,KAAA,EAAQjI,IAAS,IAAA;MACnDmG,QAAA,GAAWA,QAAS,CAAAsC,MAAA,CAAOjC,mBAAoB,CAAAxG,IAAI,CAAC,CAAA;IAAA,CACrD,CAAA;IACD,IAAI,CAAC0I,UAAY,EAAA;MACR,OAAA1E,WAAA;IACT;IAEM,MAAA2E,OAAA,GAAU1C,SAAU,CAAAC,MAAA,EAAQC,QAAQ,CAAA;IAE1C,OAAOwC,UAAU5E,UAAa,GAAAC,WAAA;EAChC,CAAA;EAEA,GAAK,EAAA,SAAS4E,IAAK,CAAAZ,IAAA,EAAMC,KAAO,EAAA;IAC9B,IAAID,IAAK,CAAAlH,IAAA,KAAS,UAAc,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACvD,OAAOmE,aAAa+C,IAAK,CAAA/G,IAAA,CAAKsD,GAAI,CAAA0D,KAAA,CAAMhH,IAAI,CAAC,CAAA;IAC/C;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACrD,OAAO+D,UAAW,CAAAmD,IAAA,CAAK/G,IAAO,GAAAgH,KAAA,CAAMhH,IAAI,CAAA;IAC1C;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACrD,OAAOkE,UAAW,CAAAgD,IAAA,CAAK/G,IAAO,GAAAgH,KAAA,CAAMhH,IAAI,CAAA;IAC1C;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MAC9C,OAAA8C,MAAA,CAAO;QAAC,GAAGoE,IAAA,CAAK/G;QAAM,GAAGgH,KAAA,CAAMhH;OAAK,CAAA;IAC7C;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,OAAW,IAAAmH,KAAA,CAAMnH,SAAS,OAAS,EAAA;MACnD,OAAO8C,OAAOoE,IAAK,CAAA/G,IAAA,CAAKwH,MAAO,CAAAR,KAAA,CAAMhH,IAAI,CAAC,CAAA;IAC5C;IAEA,IAAI+G,IAAK,CAAA9G,OAAA,EAAa,IAAA+G,KAAA,CAAM/G,SAAW,EAAA;MAC9B,OAAA,IAAIN,YAAY,mBAAmB;QACxC,WAAA,MAAiB4E,OAAOwC,IAAM,EAAA;UACtB,MAAAxC,GAAA;QACR;QAEA,WAAA,MAAiBA,OAAOyC,KAAO,EAAA;UACvB,MAAAzC,GAAA;QACR;MAAA,CACD,CAAA;IACH;IAEO,OAAA1B,UAAA;EACT,CAAA;EAEA,GAAK,EAAA,SAAS+E,KAAM,CAAAb,IAAA,EAAMC,KAAO,EAAA;IAC/B,IAAID,IAAK,CAAAlH,IAAA,KAAS,UAAc,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACvD,OAAOmE,aAAa+C,IAAK,CAAA/G,IAAA,CAAKsD,IAAI,CAAC0D,KAAA,CAAMhH,IAAI,CAAC,CAAA;IAChD;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,UAAc,IAAAmH,KAAA,CAAMnH,SAAS,UAAY,EAAA;MACzD,OAAO+D,WAAWmD,IAAK,CAAA/G,IAAA,CAAK0D,UAAW,CAAAsD,KAAA,CAAMhH,IAAI,CAAC,CAAA;IACpD;IAEA,IAAI+G,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACrD,OAAO+D,UAAW,CAAAmD,IAAA,CAAK/G,IAAO,GAAAgH,KAAA,CAAMhH,IAAI,CAAA;IAC1C;IAEO,OAAA6C,UAAA;EACT,CAAA;EAEA,KAAKgF,eAAgB,CAAA,CAACnD,CAAG,EAAAC,CAAA,KAAMD,IAAIC,CAAC,CAAA;EACpC,KAAKkD,eAAgB,CAAA,CAACnD,CAAG,EAAAC,CAAA,KAAMD,IAAIC,CAAC,CAAA;EACpC,KAAKkD,eAAgB,CAAA,CAACnD,CAAG,EAAAC,CAAA,KAAMD,IAAIC,CAAC,CAAA;EACpC,IAAA,EAAMkD,gBAAgB,CAACnD,CAAA,EAAGC,MAAMmD,IAAK,CAAAC,GAAA,CAAIrD,CAAG,EAAAC,CAAC,CAAC;AAChD,CAAA;AAEA,SAASkD,gBAAgBG,IAAwD,EAAA;EACxE,OAAA,UAAUjB,MAAMC,KAAO,EAAA;IAC5B,IAAID,IAAK,CAAAlH,IAAA,KAAS,QAAY,IAAAmH,KAAA,CAAMnH,SAAS,QAAU,EAAA;MACrD,MAAMM,MAAS,GAAA6H,IAAA,CAAKjB,IAAK,CAAA/G,IAAA,EAAMgH,MAAMhH,IAAI,CAAA;MACzC,OAAO4D,WAAWzD,MAAM,CAAA;IAC1B;IAEO,OAAA0C,UAAA;EAAA,CACT;AACF;AC9KO,MAAMoF,KAAM,CAAA;EASjB5I,WACE,CAAA6I,MAAA,EACAC,MACA,EAAA/H,KAAA,EACAgI,SACAC,MACA,EAAA;IATF,IAAA,CAAOC,QAAW,GAAA,KAAA;IAUhB,IAAA,CAAKJ,MAAS,GAAAA,MAAA;IACd,IAAA,CAAKC,MAAS,GAAAA,MAAA;IACd,IAAA,CAAK/H,KAAQ,GAAAA,KAAA;IACb,IAAA,CAAKgI,OAAU,GAAAA,OAAA;IACf,IAAA,CAAKC,MAAS,GAAAA,MAAA;EAChB;EAEAE,aAAanI,KAAqB,EAAA;IAChC,IAAI,KAAKkI,QAAU,EAAA;MACV,OAAA,IAAIL,KAAM,CAAA,IAAA,CAAKC,MAAQ,EAAA,IAAA,CAAKC,QAAQ/H,KAAO,EAAA,IAAA,CAAKgI,OAAS,EAAA,IAAA,CAAKC,MAAM,CAAA;IAC7E;IACO,OAAA,IAAIJ,MAAM,IAAK,CAAAC,MAAA,EAAQ,KAAKC,MAAQ,EAAA/H,KAAA,EAAO,IAAK,CAAAgI,OAAA,EAAS,IAAI,CAAA;EACtE;EAEAI,aAAapI,KAAqB,EAAA;IAC1B,MAAAD,MAAA,GAAS,IAAK,CAAAoI,YAAA,CAAanI,KAAK,CAAA;IACtCD,MAAA,CAAOmI,QAAW,GAAA,IAAA;IACX,OAAAnI,MAAA;EACT;AACF;ACvBO,SAASsI,QACd,CAAAC,IAAA,EACAC,KACA,EAC4B;EAAA,IAD5BC,OAAA,uEAAoBH,QACQ;EACtB,MAAAI,IAAA,GAAOC,UAAUJ,IAAK,CAAA7I,IAAA,CAAA;EACrB,OAAAgJ,IAAA,CAAKH,IAAa,EAAAC,KAAA,EAAOC,OAAO,CAAA;AACzC;AAeA,SAASG,gBAAA,CACP3I,OACA6F,EAC4B,EAAA;EAC5B,IAAI,UAAU7F,KAAO,EAAA;IACZ,OAAAA,KAAA,CAAM4I,KAAK/C,EAAE,CAAA;EACtB;EAEA,OAAOA,GAAG7F,KAAK,CAAA;AACjB;AAEA,MAAM0I,SAAyB,GAAA;EAC7BG,IAAA,CAAKC,GAAGP,KAAO,EAAA;IACb,OAAOA,KAAM,CAAAvI,KAAA;EACf,CAAA;EAEA+I,QAAW,GAAA;IAGH,MAAA,IAAIvG,MAAM,gCAAgC,CAAA;EAClD,CAAA;EAEAwG,UAAA,CAAWF,GAAGP,KAAO,EAAA;IACnB,OAAOA,KAAM,CAAAR,MAAA;EACf,CAAA;EAEAkB,SAAU,OAAQV,KAAO,EAAA;IAAA,IAAf;MAACW;IAAI,CAAA;IACN,OAAA3G,MAAA,CAAOgG,KAAM,CAAAT,MAAA,CAAOoB,IAAK,CAAA,CAAA;EAClC,CAAA;EAEAC,OAAQ,QAAOZ,KAAO,EAAA;IAAA,IAAd;MAACa;IAAG,CAAA;IACN,IAAAA,GAAA,KAAQ,QAAY,IAAAA,GAAA,KAAQ,OAAS,EAAA;MACjC,MAAApJ,KAAA,GAAQuI,MAAMP,OAAQ,CAAAoB,GAAA,CAAA;MAC5B,OAAOpJ,KAAS,IAAAyC,UAAA;IAClB;IACM,MAAA,IAAID,KAAM,gCAAwB4G,GAAK,EAAA;EAC/C,CAAA;EAEAC,MAAO,QAAKd,KAAO,EAAA;IAAA,IAAZ;MAACe;IAAC,CAAA;IACP,IAAIC,OAAU,GAAAhB,KAAA;IACd,KAAA,IAASpI,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAmJ,CAAA,EAAGnJ,CAAK,EAAA,EAAA;MACtB,IAAA,CAACoJ,QAAQtB,MAAQ,EAAA;QACZ,OAAAxF,UAAA;MACT;MAEA8G,OAAA,GAAUA,OAAQ,CAAAtB,MAAA;IACpB;IACA,OAAOsB,OAAQ,CAAAvJ,KAAA;EACjB,CAAA;EAEAwJ,cAA0BjB,OAAOC,OAAS,EAAA;IAAA,IAAnC;MAACiB,EAAA;MAAI9C;MAAMC;IAAK,CAAA;IACrB,MAAM6B,OAAOhC,SAAU,CAAAgD,EAAA,CAAA;IACvB,IAAI,CAAChB,IAAM,EAAA;MACH,MAAA,IAAIjG,KAAM,6BAAqBiH,EAAI,EAAA;IAC3C;IACM,MAAAC,SAAA,GAAYlB,OAAQ,CAAA7B,IAAA,EAAM4B,KAAK,CAAA;IAC/B,MAAAoB,UAAA,GAAanB,OAAQ,CAAA5B,KAAA,EAAO2B,KAAK,CAAA;IAInC,IAAA,MAAA,IAAUmB,SAAa,IAAA,MAAA,IAAUC,UAAY,EAAA;MAC/C,OAAA,CAAQ,YAAYlB,IAAK,CAAA,MAAMiB,SAAW,EAAA,MAAMC,UAAU,CAAG,GAAA;IAC/D;IAEO,OAAAlB,IAAA,CAAKiB,WAAWC,UAAU,CAAA;EACnC,CAAA;EAEA,MAAMC,MAAO,QAA0BrB,OAAOC,OAAS,EAAA;IAAA,IAA1C;MAACqB;MAAcC;IAAQ,CAAA;IAClC,KAAA,MAAWC,OAAOF,YAAc,EAAA;MAC9B,MAAMG,OAAU,GAAA,MAAMxB,OAAQ,CAAAuB,GAAA,CAAIE,WAAW1B,KAAK,CAAA;MAClD,IAAIyB,OAAQ,CAAAvK,IAAA,KAAS,SAAa,IAAAuK,OAAA,CAAQpK,SAAS,IAAM,EAAA;QAChD,OAAA4I,OAAA,CAAQuB,GAAI,CAAA/J,KAAA,EAAOuI,KAAK,CAAA;MACjC;IACF;IAEA,IAAIuB,QAAU,EAAA;MACL,OAAAtB,OAAA,CAAQsB,UAAUvB,KAAK,CAAA;IAChC;IAEO,OAAA9F,UAAA;EACT,CAAA;EAEA,MAAMyH,eAA0C3B,KAAA,EAAOC,OAAS,EAAA;IAAA,IAAlD;MAAC2B,IAAA;MAAMxD;MAAMC,KAAO;MAAAwD;IAAc,CAAA;IAC9C,MAAMpK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACvC,MAAMmB,SAAY,GAAA,MAAMlB,OAAQ,CAAA7B,IAAA,EAAM4B,KAAK,CAAA;IAC3C,MAAMoB,UAAa,GAAA,MAAMnB,OAAQ,CAAA5B,KAAA,EAAO2B,KAAK,CAAA;IAEvC,MAAA8B,OAAA,GAAUlE,eAAe,MAAMnG,KAAA,CAAMF,KAAO,EAAA,MAAM4J,SAAU,CAAA5J,GAAA,EAAK,CAAA;IACvE,IAAIuK,YAAY,IAAM,EAAA;MACb,OAAA5H,UAAA;IACT;IACM,MAAA6H,QAAA,GAAWnE,eAAe,MAAMnG,KAAA,CAAMF,KAAO,EAAA,MAAM6J,UAAW,CAAA7J,GAAA,EAAK,CAAA;IACzE,IAAIwK,aAAa,IAAM,EAAA;MACd,OAAA7H,UAAA;IACT;IAEA,IAAI2H,WAAa,EAAA;MACf,OAAOC,OAAW,IAAA,CAAA,IAAKC,QAAY,IAAA,CAAA,GAAI5H,UAAa,GAAAC,WAAA;IACtD;IAEA,OAAO0H,OAAW,IAAA,CAAA,IAAKC,QAAW,GAAA,CAAA,GAAI5H,UAAa,GAAAC,WAAA;EACrD,CAAA;EAEA,MAAM4H,MAAO,QAAchC,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC2B;MAAMK;IAAI,CAAA;IACtB,MAAMC,SAAY,GAAA,MAAMjC,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACvC,IAAA,CAACkC,SAAU,CAAA5K,OAAA,EAAW,EAAA;MACjB,OAAA4C,UAAA;IACT;IACO,OAAA,IAAIlD,YAAY,mBAAmB;MACxC,WAAA,MAAiBmL,QAAQD,SAAW,EAAA;QAC5B,MAAAE,QAAA,GAAWpC,KAAM,CAAAJ,YAAA,CAAauC,IAAI,CAAA;QACxC,MAAME,SAAY,GAAA,MAAMpC,OAAQ,CAAAgC,IAAA,EAAMG,QAAQ,CAAA;QAC9C,IAAIC,SAAU,CAAAnL,IAAA,KAAS,SAAa,IAAAmL,SAAA,CAAUhL,SAAS,IAAM,EAAA;UACrD,MAAA8K,IAAA;QACR;MACF;IAAA,CACD,CAAA;EACH,CAAA;EAEA,MAAMG,UAAW,QAActC,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC2B;MAAMK;IAAI,CAAA;IAC1B,MAAMC,SAAY,GAAA,MAAMjC,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACvC,IAAAkC,SAAA,CAAUhL,SAAS,QAAU,EAAA;MACxB,OAAAgD,UAAA;IACT;IAEM,MAAAkI,QAAA,GAAWpC,KAAM,CAAAJ,YAAA,CAAasC,SAAS,CAAA;IACtC,OAAAjC,OAAA,CAAQgC,MAAMG,QAAQ,CAAA;EAC/B,CAAA;EAEAG,gBAAqCvC,OAAcC,OAAS,EAAA;IAAA,IAAnD;MAACC,IAAA;MAAMsC;IAAI,CAAA;IACX,OAAAtC,IAAA,CAAKsC,IAAM,EAAAxC,KAAA,EAAOC,OAAO,CAAA;EAClC,CAAA;EAEA,MAAMwC,qBAAmDzC,OAAcC,OAAS,EAAA;IAAA,IAA7D;MAACC,IAAA;MAAM0B;MAAMY;IAAI,CAAA;IAClC,MAAMN,SAAY,GAAA,MAAMjC,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IAC3C,OAAOE,IAAK,CAAAgC,SAAA,EAAWM,IAAM,EAAAxC,KAAA,EAAOC,OAAO,CAAA;EAC7C,CAAA;EAEA,MAAMyC,eAAgB,SAAc1C,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC2B;MAAMjB;IAAI,CAAA;IAC/B,IAAIlJ,QAAQuI,KAAM,CAAAvI,KAAA;IAClB,IAAImK,IAAM,EAAA;MACAnK,KAAA,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACnC;IACI,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;MAC3B,IAAIO,KAAM,CAAAJ,IAAA,CAAKsL,cAAe,CAAAhC,IAAI,CAAG,EAAA;QAC5B,OAAA3G,MAAA,CAAOvC,KAAM,CAAAJ,IAAA,CAAKsJ,IAAK,CAAA,CAAA;MAChC;IACF;IAEO,OAAAzG,UAAA;EACT,CAAA;EAEA,MAAM0I,aAAc,SAAe5C,OAAOC,OAAS,EAAA;IAAA,IAA/B;MAAC2B;MAAMiB;IAAK,CAAA;IAC9B,MAAMX,SAAY,GAAA,MAAMjC,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACvC,IAAA,CAACkC,SAAU,CAAA5K,OAAA,EAAW,EAAA;MACjB,OAAA4C,UAAA;IACT;IAEM,MAAA7C,IAAA,GAAO,MAAM6K,SAAA,CAAU3K,GAAI,EAAA;IACjC,MAAMuL,UAAa,GAAAD,KAAA,GAAQ,CAAI,GAAAA,KAAA,GAAQxL,KAAKQ,MAAS,GAAAgL,KAAA;IAC9C,OAAA7I,MAAA,CAAO3C,KAAKyL,UAAW,CAAA,CAAA;EAChC,CAAA;EAEA,MAAMC,cAAwC/C,KAAA,EAAOC,OAAS,EAAA;IAAA,IAAlD;MAAC2B,IAAA;MAAMxD;MAAMC,KAAO;MAAAwD;IAAc,CAAA;IAC5C,MAAMK,SAAY,GAAA,MAAMjC,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IAEvC,IAAA,CAACkC,SAAU,CAAA5K,OAAA,EAAW,EAAA;MACjB,OAAA4C,UAAA;IACT;IAGM,MAAA8I,KAAA,GAAS,MAAMd,SAAA,CAAU3K,GAAI,EAAA;IAEnC,IAAI0L,OAAU,GAAA7E,IAAA;IACd,IAAI8E,QAAW,GAAA7E,KAAA;IAGf,IAAI4E,UAAU,CAAG,EAAA;MACfA,OAAA,GAAUD,MAAMnL,MAAS,GAAAoL,OAAA;IAC3B;IACA,IAAIC,WAAW,CAAG,EAAA;MAChBA,QAAA,GAAWF,MAAMnL,MAAS,GAAAqL,QAAA;IAC5B;IAGA,IAAIrB,WAAa,EAAA;MACfqB,QAAA,EAAA;IACF;IAEA,IAAID,UAAU,CAAG,EAAA;MACLA,OAAA,GAAA,CAAA;IACZ;IACA,IAAIC,WAAW,CAAG,EAAA;MACLA,QAAA,GAAA,CAAA;IACb;IAKA,OAAOlJ,MAAO,CAAAgJ,KAAA,CAAM5F,KAAM,CAAA6F,OAAA,EAASC,QAAQ,CAAC,CAAA;EAC9C,CAAA;EAEA,MAAMC,KAAM,SAAQnD,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACf,MAAMnK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IAEvC,IAAI,CAACA,KAAA,CAAMR,MAAO,CAAAlI,OAAA,EAAW,EAAA;MACpB,OAAA4C,UAAA;IACT;IAEI,IAAAzC,KAAA,CAAMP,SAAS,QAAU,EAAA;MACpB,OAAAgD,UAAA;IACT;IAEM,MAAAkJ,EAAA,GAAK3L,MAAMJ,IAAK,CAAAgM,IAAA;IAClB,IAAA,OAAOD,OAAO,QAAU,EAAA;MACnB,OAAAlJ,UAAA;IACT;IAEiB,WAAA,MAAAoJ,GAAA,IAAOtD,MAAMR,MAAQ,EAAA;MACpC,IAAI8D,IAAIpM,IAAS,KAAA,QAAA,IAAYkM,EAAO,KAAAE,GAAA,CAAIjM,KAAKkM,GAAK,EAAA;QACzC,OAAAD,GAAA;MACT;IACF;IAEO,OAAApJ,UAAA;EACT,CAAA;EAEAsJ,KAAA,SAAe;IAAA,IAAT;MAAC/L;KAAQ;IACb,OAAOuC,OAAOvC,KAAK,CAAA;EACrB,CAAA;EAEAgM,KAAM,SAAQzD,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACF,OAAA3B,OAAA,CAAQ2B,MAAM5B,KAAK,CAAA;EAC5B,CAAA;EAEA,MAAM0D,MAAO,SAAc1D,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC0D;KAAU;IACtB,MAAMnM,SAA+B,CAAA,CAAC;IACtC,KAAA,MAAWoM,QAAQD,UAAY,EAAA;MAC7B,MAAME,WAAWD,IAAK,CAAA1M,IAAA;MACtB,QAAQ0M,IAAK,CAAA1M,IAAA;QAAA,KACN,sBAAwB;UAAA;YAC3B,MAAMO,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2D,IAAA,CAAKnM,OAAOuI,KAAK,CAAA;YAC7CxI,MAAA,CAAOoM,IAAK,CAAAjD,IAAA,CAAA,GAAQ,MAAMlJ,KAAA,CAAMF,GAAI,EAAA;YACpC;UACF;QAAA,KAEK,wBAA0B;UAAA;YAC7B,MAAMuM,IAAO,GAAA,MAAM7D,OAAQ,CAAA2D,IAAA,CAAKlC,WAAW1B,KAAK,CAAA;YAChD,IAAI8D,IAAK,CAAA5M,IAAA,KAAS,SAAa,IAAA4M,IAAA,CAAKzM,SAAS,KAAO,EAAA;cAClD;YACF;YAEA,MAAMI,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2D,IAAA,CAAKnM,OAAOuI,KAAK,CAAA;YACzC,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;cACpBwM,MAAA,CAAAK,MAAA,CAAOvM,MAAQ,EAAAC,KAAA,CAAMJ,IAAI,CAAA;YAClC;YACA;UACF;QAAA,KAEK,aAAe;UAAA;YAClB,MAAMI,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2D,IAAA,CAAKnM,OAAOuI,KAAK,CAAA;YACzC,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;cACpBwM,MAAA,CAAAK,MAAA,CAAOvM,MAAQ,EAAAC,KAAA,CAAMJ,IAAI,CAAA;YAClC;YACA;UACF;QAAA;UAGQ,MAAA,IAAI4C,KAAM,8BAAsB4J,QAAU,EAAA;MAAA;IAEtD;IACA,OAAO7J,OAAOxC,MAAM,CAAA;EACtB,CAAA;EAEAsC,KAAM,SAAYkG,OAAOC,OAAS,EAAA;IAAA,IAA5B;MAAC+D;KAAQ;IACN,OAAA,IAAIhN,YAAY,mBAAmB;MACxC,KAAA,MAAW+C,WAAWiK,QAAU,EAAA;QAC9B,MAAMvM,KAAQ,GAAA,MAAMwI,OAAQ,CAAAlG,OAAA,CAAQtC,OAAOuI,KAAK,CAAA;QAChD,IAAIjG,QAAQkK,OAAS,EAAA;UACf,IAAAxM,KAAA,CAAMH,SAAW,EAAA;YACnB,WAAA,MAAiB4M,KAAKzM,KAAO,EAAA;cACrB,MAAAyM,CAAA;YACR;UACF;QAAA,CACK,MAAA;UACC,MAAAzM,KAAA;QACR;MACF;IAAA,CACD,CAAA;EACH,CAAA;EAEA0M,KAAQ,GAAA;IACA,MAAA,IAAIlK,MAAM,6BAA6B,CAAA;EAC/C,CAAA;EAEA,MAAMmK,EAAG,SAAepE,OAAOC,OAAS,EAAA;IAAA,IAA/B;MAAC7B;MAAMC;IAAK,CAAA;IACnB,MAAM8C,SAAY,GAAA,MAAMlB,OAAQ,CAAA7B,IAAA,EAAM4B,KAAK,CAAA;IAC3C,MAAMoB,UAAa,GAAA,MAAMnB,OAAQ,CAAA5B,KAAA,EAAO2B,KAAK,CAAA;IAEzC,IAAAmB,SAAA,CAAUjK,SAAS,SAAW,EAAA;MAC5B,IAAAiK,SAAA,CAAU9J,SAAS,IAAM,EAAA;QACpB,OAAA8C,UAAA;MACT;IACF;IAEI,IAAAiH,UAAA,CAAWlK,SAAS,SAAW,EAAA;MAC7B,IAAAkK,UAAA,CAAW/J,SAAS,IAAM,EAAA;QACrB,OAAA8C,UAAA;MACT;IACF;IAEA,IAAIgH,SAAU,CAAAjK,IAAA,KAAS,SAAa,IAAAkK,UAAA,CAAWlK,SAAS,SAAW,EAAA;MAC1D,OAAAgD,UAAA;IACT;IAEO,OAAAE,WAAA;EACT,CAAA;EAEA,MAAMiK,GAAI,SAAerE,OAAOC,OAAS,EAAA;IAAA,IAA/B;MAAC7B;MAAMC;IAAK,CAAA;IACpB,MAAM8C,SAAY,GAAA,MAAMlB,OAAQ,CAAA7B,IAAA,EAAM4B,KAAK,CAAA;IAC3C,MAAMoB,UAAa,GAAA,MAAMnB,OAAQ,CAAA5B,KAAA,EAAO2B,KAAK,CAAA;IAEzC,IAAAmB,SAAA,CAAUjK,SAAS,SAAW,EAAA;MAC5B,IAAAiK,SAAA,CAAU9J,SAAS,KAAO,EAAA;QACrB,OAAA+C,WAAA;MACT;IACF;IAEI,IAAAgH,UAAA,CAAWlK,SAAS,SAAW,EAAA;MAC7B,IAAAkK,UAAA,CAAW/J,SAAS,KAAO,EAAA;QACtB,OAAA+C,WAAA;MACT;IACF;IAEA,IAAI+G,SAAU,CAAAjK,IAAA,KAAS,SAAa,IAAAkK,UAAA,CAAWlK,SAAS,SAAW,EAAA;MAC1D,OAAAgD,UAAA;IACT;IAEO,OAAAC,UAAA;EACT,CAAA;EAEA,MAAMmK,GAAI,SAAQtE,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACb,MAAMnK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACnC,IAAAvI,KAAA,CAAMP,SAAS,SAAW,EAAA;MACrB,OAAAgD,UAAA;IACT;IACO,OAAAzC,KAAA,CAAMJ,OAAO+C,WAAc,GAAAD,UAAA;EACpC,CAAA;EAEAoK,GAAI,SAAQvE,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACP,OAAOxB,iBAAiBH,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA,EAAIvI,KAAU,IAAA;MACnD,IAAAA,KAAA,CAAMP,SAAS,QAAU,EAAA;QACpB,OAAAgD,UAAA;MACT;MACO,OAAAe,UAAA,CAAW,CAACxD,KAAA,CAAMJ,IAAI,CAAA;IAAA,CAC9B,CAAA;EACH,CAAA;EAEAmN,GAAI,SAAQxE,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACP,OAAOxB,iBAAiBH,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA,EAAIvI,KAAU,IAAA;MACnD,IAAAA,KAAA,CAAMP,SAAS,QAAU,EAAA;QACpB,OAAAgD,UAAA;MACT;MACO,OAAAe,UAAA,CAAWxD,MAAMJ,IAAI,CAAA;IAAA,CAC7B,CAAA;EACH,CAAA;EAEAoN,GAAM,GAAA;IACG,OAAAvK,UAAA;EACT,CAAA;EAEAwK,IAAO,GAAA;IACE,OAAAxK,UAAA;EACT,CAAA;EAEA,MAAMyK,WAAY,SAAQ3E,OAAOC,OAAS,EAAA;IAAA,IAAxB;MAAC2B;KAAI;IACrB,MAAMnK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IAChC,OAAAvI,KAAA,CAAMH,OAAQ,EAAA,GAAIG,KAAQ,GAAAyC,UAAA;EACnC,CAAA;EAEA,MAAM0K,GAAI,SAAc5E,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC2B;MAAMK;IAAI,CAAA;IACnB,MAAMxK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACnC,IAAA,CAACvI,KAAM,CAAAH,OAAA,EAAW,EAAA;MACb,OAAA4C,UAAA;IACT;IAEO,OAAA,IAAIlD,YAAY,mBAAmB;MACxC,WAAA,MAAiBmL,QAAQ1K,KAAO,EAAA;QACxB,MAAA2K,QAAA,GAAWpC,KAAM,CAAAH,YAAA,CAAasC,IAAI,CAAA;QAClC,MAAA,MAAMlC,OAAQ,CAAAgC,IAAA,EAAMG,QAAQ,CAAA;MACpC;IAAA,CACD,CAAA;EACH,CAAA;EAEA,MAAMyC,OAAQ,SAAc7E,OAAOC,OAAS,EAAA;IAAA,IAA9B;MAAC2B;MAAMK;IAAI,CAAA;IACvB,MAAMxK,KAAQ,GAAA,MAAMwI,OAAQ,CAAA2B,IAAA,EAAM5B,KAAK,CAAA;IACnC,IAAA,CAACvI,KAAM,CAAAH,OAAA,EAAW,EAAA;MACb,OAAA4C,UAAA;IACT;IAEO,OAAA,IAAIlD,YAAY,mBAAmB;MACxC,WAAA,MAAiBmL,QAAQ1K,KAAO,EAAA;QACxB,MAAA2K,QAAA,GAAWpC,KAAM,CAAAH,YAAA,CAAasC,IAAI,CAAA;QACxC,MAAM2C,UAAa,GAAA,MAAM7E,OAAQ,CAAAgC,IAAA,EAAMG,QAAQ,CAAA;QAC3C,IAAA0C,UAAA,CAAWxN,SAAW,EAAA;UACxB,WAAA,MAAiByN,SAASD,UAAY,EAAA;YAC9B,MAAAC,KAAA;UACR;QAAA,CACK,MAAA;UACC,MAAAD,UAAA;QACR;MACF;IAAA,CACD,CAAA;EACH;AACF,CAAA;AAKO,SAASE,aACd,CAAAC,IAAA,EAE4B;EAAA,IAD5BC,OAA2B,uEAAA,EACC;EACtB,MAAAC,IAAA,GAAOnL,MAAO,CAAAkL,OAAA,CAAQC,IAAI,CAAA;EAC1B,MAAAC,OAAA,GAAUpL,MAAO,CAAAkL,OAAA,CAAQE,OAAO,CAAA;EACtC,MAAM7F,MAA+B,GAAA;IAAC,GAAG2F,OAAA,CAAQ3F;EAAM,CAAA;EAEvD,MAAMS,QAAQ,IAAIV,KAAA,CAChBC,MAAA,EACA6F,OAAA,EACAD,IAAA,EACA;IACEE,SAAW,EAAAH,OAAA,CAAQG,SAAa,IAAA,IAAI9M,IAAK,EAAA;IACzC+M,QAAU,EAAAJ,OAAA,CAAQI,QAAa,KAAA,KAAA,CAAA,GAAY,OAAOJ,OAAQ,CAAAI,QAAA;IAC1DC,QAAQL,OAAQ,CAAAK,MAAA;IAChBC,OAAON,OAAQ,CAAAM,KAAA,GAAQxL,MAAO,CAAAkL,OAAA,CAAQM,KAAK,CAAI,GAAA,IAAA;IAC/CC,QAAQP,OAAQ,CAAAO,MAAA,GAASzL,MAAO,CAAAkL,OAAA,CAAQO,MAAM,CAAI,GAAA;EACpD,CAAA,EACA,IAAA,CACF;EACO,OAAA3F,QAAA,CAASmF,MAAMjF,KAAK,CAAA;AAC7B;ACzdA,SAAS0F,oBAAoB3F,IAAyB,EAAA;EACpD,QAAQA,IAAK,CAAA7I,IAAA;IACN,KAAA,OAAA;IACA,KAAA,OAAA;IACA,KAAA,WAAA;MACI,OAAA,IAAA;IACJ,KAAA,KAAA;IACA,KAAA,KAAA;MACI,OAAAwO,mBAAA,CAAoB3F,KAAK6B,IAAI,CAAA;IACjC,KAAA,QAAA;MACH,QAAQ7B,IAAK,CAAAmB,EAAA;QACN,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,GAAA;QACA,KAAA,IAAA;UACH,OAAOwE,oBAAoB3F,IAAK,CAAA3B,IAAI,CAAK,IAAAsH,mBAAA,CAAoB3F,KAAK1B,KAAK,CAAA;QAAA;UAEhE,OAAA,KAAA;MAAA;IAAA;MAGJ,OAAA,KAAA;EAAA;AAEb;AAEA,MAAMsH,cAAc,IAAIrG,KAAA,CACtB,CAAC,CAAA,EACDpF,UAAA,EACAA,UAAA,EACA;EAACmL,SAAW,EAAA,IAAI9M,IAAK,CAAA,CAAC,CAAG;EAAA+M,QAAA,EAAU,IAAM;EAAAG,MAAA,EAAQ,IAAM;EAAAD,KAAA,EAAO;AAAI,CAAA,EAClE,IAAA,CACF;AAEO,SAASI,oBAAoB7F,IAA8B,EAAA;EAC5D,IAAA,CAAC2F,mBAAoB,CAAA3F,IAAI,CAAG,EAAA;IACvB,OAAA,IAAA;EACT;EAEA,OAAO8F,iBAAiB9F,IAAI,CAAA;AAC9B;AAEA,SAAS8F,iBAAiB9F,IAAuB,EAAA;EAC/C,MAAMtI,KAAQ,GAAAqI,QAAA,CAASC,IAAM,EAAA4F,WAAA,EAAaE,gBAAgB,CAAA;EAC1D,IAAI,UAAUpO,KAAO,EAAA;IACb,MAAA,IAAIwC,MAAM,sDAAsD,CAAA;EACxE;EACO,OAAAxC,KAAA;AACT;ACnDA,eAAsBqO,oBAAoBrO,KAAsC,EAAA;EAC1E,IAAAA,KAAA,CAAMP,SAAS,QAAU,EAAA;IACpB,OAAA6O,SAAA,CAAUtO,MAAMJ,IAAI,CAAA;EAAA,CAC7B,MAAA,IAAWI,KAAM,CAAAH,OAAA,EAAW,EAAA;IACpB,MAAA0O,KAAA,GAAQ,MAAMC,SAAA,CAAUxO,KAAK,CAAA;IAC/B,IAAAuO,KAAA,CAAMnO,SAAS,CAAG,EAAA;MACb,OAAAmO,KAAA,CAAMxP,KAAK,MAAM,CAAA;IAC1B;EACF;EAEO,OAAA,IAAA;AACT;AAEA,eAAeyP,SAAU,CAAAxO,KAAA,EAAwD;EAAA,IAA1CD,MAAmB,uEAAA,EAAuB;EAC/E,WAAA,MAAiB0O,SAASzO,KAAO,EAAA;IAC3B,IAAAyO,KAAA,CAAMhP,SAAS,QAAU,EAAA;MACrB,MAAAwF,IAAA,GAAOqJ,SAAU,CAAAG,KAAA,CAAM7O,IAAI,CAAA;MACjC,IAAIqF,IAAS,KAAA,IAAA,EAAMlF,MAAA,CAAOlB,KAAKoG,IAAI,CAAA;IAAA,CACrC,MAAA,IAAWwJ,KAAM,CAAA5O,OAAA,EAAW,EAAA;MACpB,MAAA2O,SAAA,CAAUC,OAAO1O,MAAM,CAAA;IAC/B;EACF;EAEO,OAAAA,MAAA;AACT;AAEA,SAASuO,UAAUrK,GAA6C,EAAA;EAC1D,IAAA,OAAOA,IAAIyK,KAAU,KAAA,QAAA,EAAiB,OAAA,IAAA;EAC1C,MAAMC,WAAW1K,GAAI,CAAA0K,QAAA;EACjB,IAAA,CAACtM,KAAM,CAAAxC,OAAA,CAAQ8O,QAAQ,CAAA,EAAU,OAAA,IAAA;EAErC,IAAI5O,MAAS,GAAA,EAAA;EACb,KAAA,MAAW6O,SAASD,QAAU,EAAA;IAC5B,IACEC,KACA,IAAA,OAAOA,KAAU,KAAA,QAAA,IACjB,OAAOA,KAAM,CAAAF,KAAA,KAAU,QACvB,IAAAE,KAAA,CAAMF,KAAU,KAAA,MAAA,IAChB,OAAOE,KAAA,CAAM3J,SAAS,QACtB,EAAA;MACAlF,MAAA,IAAU6O,KAAM,CAAA3J,IAAA;IAClB;EACF;EACO,OAAAlF,MAAA;AACT;ACxCA,MAAM8O,KAAQ,GAAA,GAAA;AAEQ,eAAAC,aAAA,CACpBxG,IACA,EAAAC,KAAA,EACAC,OACiB,EAAA;EACjB,IAAIF,IAAK,CAAA7I,IAAA,KAAS,QAAY,IAAA6I,IAAA,CAAKmB,OAAO,OAAS,EAAA;IACjD,OAAOsF,mBAAmBzG,IAAK,CAAA3B,IAAA,EAAM2B,IAAK,CAAA1B,KAAA,EAAO2B,OAAOC,OAAO,CAAA;EACjE;EAEA,IAAIF,IAAK,CAAA7I,IAAA,KAAS,UAAc,IAAA6I,IAAA,CAAKY,SAAS,OAAS,EAAA;IACrD,MAAM8F,aAAa,MAAMF,aAAA,CAAcxG,KAAKyC,IAAK,CAAA,CAAA,CAAA,EAAIxC,OAAOC,OAAO,CAAA;IACnE,MAAMyG,QAAQ,MAAMzG,OAAA,CAAQF,IAAK,CAAAyC,IAAA,CAAK,IAAIxC,KAAK,CAAA;IAC/C,IAAI0G,KAAM,CAAAxP,IAAA,KAAS,QAAY,IAAAuP,UAAA,GAAa,CAAG,EAAA;MAC7C,OAAOA,aAAaC,KAAM,CAAArP,IAAA;IAC5B;IAEO,OAAA,CAAA;EACT;EAEA,QAAQ0I,IAAK,CAAA7I,IAAA;IAAA,KACN,IAAM;MAAA;QACT,MAAMyP,YAAY,MAAMJ,aAAA,CAAcxG,IAAK,CAAA3B,IAAA,EAAM4B,OAAOC,OAAO,CAAA;QAC/D,MAAM2G,aAAa,MAAML,aAAA,CAAcxG,IAAK,CAAA1B,KAAA,EAAO2B,OAAOC,OAAO,CAAA;QACjE,OAAO0G,SAAY,GAAAC,UAAA;MACrB;IAAA,KACK,KAAO;MAAA;QACV,MAAMD,YAAY,MAAMJ,aAAA,CAAcxG,IAAK,CAAA3B,IAAA,EAAM4B,OAAOC,OAAO,CAAA;QAC/D,MAAM2G,aAAa,MAAML,aAAA,CAAcxG,IAAK,CAAA1B,KAAA,EAAO2B,OAAOC,OAAO,CAAA;QAC7D,IAAA0G,SAAA,KAAc,KAAKC,UAAe,KAAA,CAAA,EAAU,OAAA,CAAA;QAChD,OAAOD,SAAY,GAAAC,UAAA;MACrB;IACS;MAAA;QACP,MAAMC,GAAM,GAAA,MAAM5G,OAAQ,CAAAF,IAAA,EAAMC,KAAK,CAAA;QACrC,OAAO6G,IAAI3P,IAAS,KAAA,SAAA,IAAa2P,GAAI,CAAAxP,IAAA,KAAS,OAAO,CAAI,GAAA,CAAA;MAC3D;EAAA;AAEJ;AAEA,eAAemP,kBACb,CAAApI,IAAA,EACAC,KACA,EAAA2B,KAAA,EACAC,OACiB,EAAA;EACjB,MAAMvD,IAAO,GAAA,MAAMuD,OAAQ,CAAA7B,IAAA,EAAM4B,KAAK,CAAA;EACtC,MAAM9J,OAAU,GAAA,MAAM+J,OAAQ,CAAA5B,KAAA,EAAO2B,KAAK,CAAA;EAE1C,IAAI1D,SAAkB,EAAC;EACvB,IAAIY,QAAkB,EAAC;EAEjB,MAAAG,UAAA,CAAWX,IAAM,EAACtG,IAAS,IAAA;IAC/BkG,MAAA,GAASA,MAAO,CAAAuC,MAAA,CAAOpC,aAAc,CAAArG,IAAI,CAAC,CAAA;EAAA,CAC3C,CAAA;EAED,MAAM0I,UAAa,GAAA,MAAMzB,UAAW,CAAAnH,OAAA,EAAUE,IAAS,IAAA;IACrD8G,KAAA,GAAQA,KAAM,CAAA2B,MAAA,CAAO/B,iBAAkB,CAAA1G,IAAI,CAAC,CAAA;EAAA,CAC7C,CAAA;EAED,IAAI,CAAC0I,UAAY,EAAA;IACR,OAAA,CAAA;EACT;EAEA,IAAIxC,MAAO,CAAAzE,MAAA,KAAW,CAAK,IAAAqF,KAAA,CAAMrF,WAAW,CAAG,EAAA;IACtC,OAAA,CAAA;EACT;EAEA,IAAIiP,KAAQ,GAAA,CAAA;EAEZ,KAAA,MAAW3Q,MAAM+G,KAAO,EAAA;IACtB,MAAM6J,IAAO,GAAAzK,MAAA,CAAO0K,MAAO,CAAA,CAACC,CAAG,EAAAhK,KAAA,KAAUgK,CAAK,IAAA9Q,EAAA,CAAGW,IAAK,CAAAmG,KAAK,CAAI,GAAA,CAAA,GAAI,IAAI,CAAC,CAAA;IAC9D6J,KAAA,IAAAC,IAAA,IAAQT,KAAQ,GAAA,CAAA,CAAA,IAAOS,IAAO,GAAAT,KAAA,CAAA;EAC1C;EAEO,OAAAQ,KAAA;AACT;AC7DA,SAASI,YAAA,CAAazP,OAAY0P,OAA+B,EAAA;EAC/D,QAAQtL,QAAQpE,KAAK,CAAA;IACd,KAAA,OAAA;MACH,KAAA,MAAWyM,KAAKzM,KAAO,EAAA;QACjB,IAAAyP,YAAA,CAAahD,CAAG,EAAAiD,OAAO,CAAG,EAAA;UACrB,OAAA,IAAA;QACT;MACF;MACA;IACG,KAAA,QAAA;MACH,IAAI1P,MAAM4L,IAAM,EAAA;QACP,OAAA8D,OAAA,CAAQC,GAAI,CAAA3P,KAAA,CAAM4L,IAAI,CAAA;MAC/B;MACA,KAAA,MAAWa,CAAK,IAAAR,MAAA,CAAO2D,MAAO,CAAA5P,KAAK,CAAG,EAAA;QAChC,IAAAyP,YAAA,CAAahD,CAAG,EAAAiD,OAAO,CAAG,EAAA;UACrB,OAAA,IAAA;QACT;MACF;MACA;EAAA;EAGG,OAAA,KAAA;AACT;AAEA,SAASG,UAAUzQ,GAAqB,EAAA;EACtC,IAAI0Q,MAAQ,GAAA,CAAA;EACZ,KAAA,IAAS3P,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAf,GAAA,CAAIgB,QAAQD,CAAK,EAAA,EAAA;IAC7B,MAAA4P,IAAA,GAAO3Q,GAAI,CAAA4Q,UAAA,CAAW7P,CAAC,CAAA;IACzB,IAAA4P,IAAA,IAAQ,KAAU,IAAAA,IAAA,IAAQ,KAAQ,EAAA;MAIpC;IACF;IACAD,MAAAA,EAAAA;EACF;EACOA,OAAAA,MAAAA;AACT;AAqBA,MAAMG,UAAuB,CAAA,CAAC;AAG9BA,OAAQ,CAAAC,QAAA,GAAW,eAAeA,QAAW,GAAA;EACrC,MAAA,IAAI1N,MAAM,iBAAiB,CAAA;AACnC,CAAA;AAEAyN,OAAA,CAAQC,SAASC,KAAQ,GAAA,CAAA;AAEzBF,OAAA,CAAQG,QAAW,GAAA,eAAeA,QAAS,CAAArF,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC/D,KAAA,MAAW6H,OAAOtF,IAAM,EAAA;IACtB,MAAM/K,KAAQ,GAAA,MAAMwI,OAAQ,CAAA6H,GAAA,EAAK9H,KAAK,CAAA;IAClC,IAAAvI,KAAA,CAAMP,SAAS,MAAQ,EAAA;MAClB,OAAAO,KAAA;IACT;EACF;EACO,OAAAyC,UAAA;AACT,CAAA;AAEAwN,OAAA,CAAQH,KAAQ,GAAA,eAAeA,KAAM,CAAA/E,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EACzD,MAAM8E,KAAQ,GAAA,MAAM9E,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACtC,IAAA,CAAC+E,KAAM,CAAAzN,OAAA,EAAW,EAAA;IACb,OAAA4C,UAAA;EACT;EAEA,IAAIR,GAAM,GAAA,CAAA;EAEV,WAAA,MAAiB6G,KAAKwE,KAAO,EAAA;IAC3BrL,GAAA,EAAA;EACF;EACA,OAAOuB,WAAWvB,GAAG,CAAA;AACvB,CAAA;AACAgO,OAAA,CAAQH,MAAMK,KAAQ,GAAA,CAAA;AAEtBF,OAAA,CAAQK,QAAW,GAAA,eAAeA,QAAS,CAAAvF,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC/D,MAAMrE,GAAM,GAAA,MAAMqE,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAApE,GAAA,CAAI1E,SAAS,UAAY,EAAA;IACpB,OAAA0E,GAAA;EACT;EACI,IAAAA,GAAA,CAAI1E,SAAS,QAAU,EAAA;IAClB,OAAAgD,UAAA;EACT;EACO,OAAAG,QAAA,CAASE,YAAa,CAAAqB,GAAA,CAAIvE,IAAI,CAAA;AACvC,CAAA;AACAqQ,OAAA,CAAQK,SAASH,KAAQ,GAAA,CAAA;AAEzBF,OAAA,CAAQM,OAAU,GAAA,eAAeA,OAAQ,CAAAxF,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC7D,MAAM8E,KAAQ,GAAA,MAAM9E,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACnC,OAAA+E,KAAA,CAAM7N,IAAS,KAAA,MAAA,GAASkD,WAAc,GAAAD,UAAA;AAC/C,CAAA;AACAuN,OAAA,CAAQM,QAAQJ,KAAQ,GAAA,CAAA;AAGxBF,OAAA,CAAQpC,QAAW,GAAA,eAAeA,QAAS,CAAA9C,IAAA,EAAMxC,KAAO,EAAA;EAC/C,OAAA5E,UAAA,CAAW4E,KAAM,CAAAP,OAAA,CAAQ6F,QAAQ,CAAA;AAC1C,CAAA;AACAoC,OAAA,CAAQpC,SAASsC,KAAQ,GAAA,CAAA;AAEzBF,OAAA,CAAQ7P,MAAS,GAAA,eAAeA,MAAO,CAAA2K,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC3D,MAAM8E,KAAQ,GAAA,MAAM9E,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EAEtC,IAAA+E,KAAA,CAAM7N,SAAS,QAAU,EAAA;IAC3B,OAAO+D,UAAW,CAAAqM,SAAA,CAAUvC,KAAM,CAAA1N,IAAI,CAAC,CAAA;EACzC;EAEI,IAAA0N,KAAA,CAAMzN,SAAW,EAAA;IACnB,IAAIoC,GAAM,GAAA,CAAA;IAEV,WAAA,MAAiB6G,KAAKwE,KAAO,EAAA;MAC3BrL,GAAA,EAAA;IACF;IACA,OAAOuB,WAAWvB,GAAG,CAAA;EACvB;EAEO,OAAAQ,UAAA;AACT,CAAA;AACAwN,OAAA,CAAQ7P,OAAO+P,KAAQ,GAAA,CAAA;AAEvBF,OAAA,CAAQlM,IAAO,GAAA,eAAeA,IAAK,CAAAgH,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EACvD,MAAM8E,KAAQ,GAAA,MAAM9E,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACtC,IAAA+E,KAAA,CAAM7N,SAAS,QAAU,EAAA;IACpB,OAAAgD,UAAA;EACT;EAEA,OAAOqB,QAAS,CAAA,IAAI9E,IAAK,CAAAsO,KAAA,CAAM1N,IAAI,CAAC,CAAA;AACtC,CAAA;AACAqQ,OAAA,CAAQlM,KAAKoM,KAAQ,GAAA,CAAA;AAErBF,OAAA,CAAQ3R,MAAS,GAAA,eAAeA,MAAO,CAAAyM,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC3D,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EAC1C,QAAQvI,KAAM,CAAAP,IAAA;IACP,KAAA,QAAA;IACA,KAAA,QAAA;IACA,KAAA,SAAA;IACA,KAAA,UAAA;MACI,OAAAkE,UAAA,WAAc3D,KAAA,CAAMJ,IAAM,EAAA;IAAA;MAE1B,OAAA6C,UAAA;EAAA;AAEb,CAAA;AACAwN,OAAA,CAAQ3R,OAAO6R,KAAQ,GAAA,CAAA;AAEvBF,OAAA,CAAQO,UAAa,GAAA,eAAeA,UAAW,CAAAzF,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAC7D,MAAAkH,OAAA,GAAA,mBAAce,GAAY,EAAA;EAChC,KAAA,MAAWJ,OAAOtF,IAAM,EAAA;IACtB,MAAMhH,KAAO,GAAA,MAAMyE,OAAQ,CAAA6H,GAAA,EAAK9H,KAAK,CAAA;IACjCxE,IAAAA,KAAAA,CAAKtE,SAAS,QAAU,EAAA;MAClBiQ,OAAA,CAAAxM,GAAA,CAAIa,MAAKnE,IAAI,CAAA;IAAA,CACvB,MAAA,IAAWmE,KAAK,CAAAlE,OAAA,EAAW,EAAA;MACzB,WAAA,MAAiB6K,QAAQ3G,KAAM,EAAA;QACzB,IAAA2G,IAAA,CAAKjL,SAAS,QAAU,EAAA;UAClBiQ,OAAA,CAAAxM,GAAA,CAAIwH,KAAK9K,IAAI,CAAA;QACvB;MACF;IACF;EACF;EAEI,IAAA8P,OAAA,CAAQgB,SAAS,CAAG,EAAA;IACf,OAAA/N,WAAA;EACT;EAEA,MAAMgO,UAAa,GAAA,MAAMpI,KAAM,CAAAvI,KAAA,CAAMF,GAAI,EAAA;EACzC,OAAO2P,YAAa,CAAAkB,UAAA,EAAYjB,OAAO,CAAA,GAAIhN,UAAa,GAAAC,WAAA;AAC1D,CAAA;AACAsN,OAAA,CAAQO,UAAW,CAAAL,KAAA,GAASX,CAAA,IAAMA,CAAK,IAAA,CAAA;AAEvCS,OAAA,CAAQW,KAAQ,GAAA,eAAeA,KAAM,CAAA7F,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EACzD,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACtC,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;IACpB,OAAAgD,UAAA;EACT;EAEA,MAAMR,MAAMjC,KAAM,CAAAJ,IAAA;EAClB,IAAIiR,IAAO,GAAA,CAAA;EAEP,IAAA9F,IAAA,CAAK3K,WAAW,CAAG,EAAA;IACrB,MAAM0Q,SAAY,GAAA,MAAMtI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;IAC1C,IAAAuI,SAAA,CAAUrR,IAAS,KAAA,QAAA,IAAYqR,SAAU,CAAAlR,IAAA,GAAO,CAAK,IAAA,CAAC6D,MAAO,CAAAsN,SAAA,CAAUD,SAAU,CAAAlR,IAAI,CAAG,EAAA;MACnF,OAAA6C,UAAA;IACT;IACAoO,IAAA,GAAOC,SAAU,CAAAlR,IAAA;EACnB;EAEA,IAAIiR,SAAS,CAAG,EAAA;IACd,IAAI5O,MAAM,CAAG,EAAA;MAGX,OAAOuB,WAAW,CAACkE,IAAA,CAAKkJ,KAAM,CAAA,CAAC3O,GAAG,CAAC,CAAA;IACrC;IACA,OAAOuB,UAAW,CAAAkE,IAAA,CAAKkJ,KAAM,CAAA3O,GAAG,CAAC,CAAA;EACnC;EACA,OAAOuB,WAAWC,MAAO,CAAAxB,GAAA,CAAI+O,OAAQ,CAAAH,IAAI,CAAC,CAAC,CAAA;AAC7C,CAAA;AACAZ,OAAA,CAAQW,MAAMT,KAAQ,GAACL,MAAUA,IAAAA,MAAAA,IAAS,KAAKA,MAAS,IAAA,CAAA;AAGxDG,OAAA,CAAQgB,GAAM,GAAA,eAAeA,GAAI,CAAAlG,IAAA,EAAMxC,KAAO,EAAA;EAC5C,OAAO5E,UAAW,CAAA4E,KAAA,CAAMP,OAAQ,CAAA4F,SAAA,CAAUsD,aAAa,CAAA;AACzD,CAAA;AACAjB,OAAA,CAAQgB,IAAId,KAAQ,GAAA,CAAA;AAGpBF,OAAQ,CAAAhB,KAAA,GAAQ,eAAeA,KAAQ,GAAA;EAE/B,MAAA,IAAIzM,MAAM,uBAAuB,CAAA;AACzC,CAAA;AAEAyN,OAAA,CAAQhB,MAAMkB,KAAQ,GAAA,CAAA;AAEtB,MAAM7R,UAAsB,CAAA,CAAC;AAE7BA,OAAAA,CAAO6S,KAAQ,GAAA,gBAAgBpG,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACnD,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EAEtC,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;IACpB,OAAAgD,UAAA;EACT;EAEA,OAAOkB,UAAW,CAAA3D,KAAA,CAAMJ,IAAK,CAAAwR,WAAA,EAAa,CAAA;AAC5C,CAAA;AACA9S,OAAAA,CAAO6S,MAAMhB,KAAQ,GAAA,CAAA;AAErB7R,OAAAA,CAAO+S,KAAQ,GAAA,gBAAgBtG,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACnD,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EAEtC,IAAAvI,KAAA,CAAMP,SAAS,QAAU,EAAA;IACpB,OAAAgD,UAAA;EACT;EAEA,OAAOkB,UAAW,CAAA3D,KAAA,CAAMJ,IAAK,CAAA0R,WAAA,EAAa,CAAA;AAC5C,CAAA;AACAhT,OAAAA,CAAO+S,MAAMlB,KAAQ,GAAA,CAAA;AAErB7R,OAAAA,CAAOM,KAAQ,GAAA,gBAAgBmM,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACnD,MAAMpJ,GAAM,GAAA,MAAMoJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAAnJ,GAAA,CAAIK,SAAS,QAAU,EAAA;IAClB,OAAAgD,UAAA;EACT;EACA,MAAM8O,GAAM,GAAA,MAAM/I,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAAgJ,GAAA,CAAI9R,SAAS,QAAU,EAAA;IAClB,OAAAgD,UAAA;EACT;EAEI,IAAArD,GAAA,CAAIQ,IAAK,CAAAQ,MAAA,KAAW,CAAG,EAAA;IAClB,OAAAmC,MAAA,CAAO,EAAE,CAAA;EAClB;EACI,IAAAgP,GAAA,CAAI3R,IAAK,CAAAQ,MAAA,KAAW,CAAG,EAAA;IAEzB,OAAOmC,MAAO,CAAAF,KAAA,CAAMmP,IAAK,CAAApS,GAAA,CAAIQ,IAAI,CAAC,CAAA;EACpC;EACA,OAAO2C,OAAOnD,GAAI,CAAAQ,IAAA,CAAKhB,KAAM,CAAA2S,GAAA,CAAI3R,IAAI,CAAC,CAAA;AACxC,CAAA;AACAtB,OAAAA,CAAOM,MAAMuR,KAAQ,GAAA,CAAA;AAErBF,OAAA,CAAQkB,QAAQ7S,OAAO,CAAA6S,KAAA;AACvBlB,OAAA,CAAQoB,QAAQ/S,OAAO,CAAA+S,KAAA;AAEvB/S,OAAAA,CAAOmT,UAAa,GAAA,gBAAgB1G,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACxD,MAAMpJ,GAAM,GAAA,MAAMoJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAAnJ,GAAA,CAAIK,SAAS,QAAU,EAAA;IAClB,OAAAgD,UAAA;EACT;EAEA,MAAMiP,MAAS,GAAA,MAAMlJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACvC,IAAAmJ,MAAA,CAAOjS,SAAS,QAAU,EAAA;IACrB,OAAAgD,UAAA;EACT;EAEA,OAAOrD,IAAIQ,IAAK,CAAA6R,UAAA,CAAWC,MAAO,CAAA9R,IAAI,IAAI8C,UAAa,GAAAC,WAAA;AACzD,CAAA;AACArE,OAAAA,CAAOmT,WAAWtB,KAAQ,GAAA,CAAA;AAE1B,MAAM5E,QAAqB,CAAA,CAAC;AAE5BA,KAAA,CAAMxM,IAAO,GAAA,gBAAgBgM,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACjD,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EACA,MAAM8O,GAAM,GAAA,MAAM/I,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAAgJ,GAAA,CAAI9R,SAAS,QAAU,EAAA;IAClB,OAAAgD,UAAA;EACT;EACA,IAAImP,GAAM,GAAA,EAAA;EACV,IAAIC,OAAU,GAAA,KAAA;EACd,WAAA,MAAiBnH,QAAQiH,GAAK,EAAA;IAC5B,IAAIE,OAAS,EAAA;MACXD,GAAA,IAAOL,GAAI,CAAA3R,IAAA;IACb;IACA,QAAQ8K,IAAK,CAAAjL,IAAA;MACN,KAAA,QAAA;MACA,KAAA,QAAA;MACA,KAAA,SAAA;MACA,KAAA,UAAA;QACHmS,GAAA,cAAUlH,IAAK,CAAA9K,IAAA,CAAA;QACf;MAAA;QAEO,OAAA6C,UAAA;IAAA;IAEDoP,OAAA,GAAA,IAAA;EACZ;EACA,OAAOtP,OAAOqP,GAAG,CAAA;AACnB,CAAA;AACArG,KAAA,CAAMxM,KAAKoR,KAAQ,GAAA,CAAA;AAEnB5E,KAAA,CAAMuG,OAAU,GAAA,gBAAgB/G,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACpD,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EAEO,OAAA,IAAIlD,YAAY,mBAAmB;IACxC,WAAA,MAAiBmL,QAAQiH,GAAK,EAAA;MACxB,IAAAjH,IAAA,CAAKjL,SAAS,MAAQ,EAAA;QAClB,MAAAiL,IAAA;MACR;IACF;EAAA,CACD,CAAA;AACH,CAAA;AACAa,KAAA,CAAMuG,QAAQ3B,KAAQ,GAAA,CAAA;AAEtB5E,KAAA,CAAMwG,MAAS,GAAA,gBAAgBhH,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EACnD,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACtC,IAAA,CAACvI,KAAM,CAAAH,OAAA,EAAW,EAAA;IACb,OAAA4C,UAAA;EACT;EAEO,OAAA,IAAIlD,YAAY,mBAAmB;IAClC,MAAAyS,KAAA,GAAA,mBAAYvB,GAAI,EAAA;IACtB,WAAA,MAAiBwB,QAAQjS,KAAO,EAAA;MAC9B,QAAQiS,IAAK,CAAAxS,IAAA;QACN,KAAA,QAAA;QACA,KAAA,QAAA;QACA,KAAA,SAAA;QACA,KAAA,UAAA;UACH,IAAI,CAACuS,KAAA,CAAMrC,GAAI,CAAAsC,IAAA,CAAKrS,IAAI,CAAG,EAAA;YACnBoS,KAAA,CAAA9O,GAAA,CAAI+O,KAAKrS,IAAI,CAAA;YACb,MAAAqS,IAAA;UACR;UACA;QAAA;UAEM,MAAAA,IAAA;MAAA;IAEZ;EAAA,CACD,CAAA;AACH,CAAA;AACA1G,KAAA,CAAMwG,OAAO5B,KAAQ,GAAA,CAAA;AAErB,MAAM+B,KAAkB,CAAA,CAAC;AACzBA,EAAA,CAAGjN,IAAO,GAAA,gBAAgB8F,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EAC9C,MAAMxI,KAAQ,GAAA,MAAMwI,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,MAAAtD,IAAA,GAAO,MAAMoJ,mBAAA,CAAoBrO,KAAK,CAAA;EAE5C,IAAIiF,SAAS,IAAM,EAAA;IACV,OAAAxC,UAAA;EACT;EAEA,OAAOkB,WAAWsB,IAAI,CAAA;AACxB,CAAA;AAEAiN,EAAA,CAAGjN,KAAKkL,KAAQ,GAAA,CAAA;AAEhB,MAAMrC,SAAsB,CAAA,CAAC;AAE7BA,MAAO,CAAAqE,SAAA,GAAY,gBAAgBpH,IAAA,EAAMxC,KAAO,EAAA;EAC1C,IAAAA,KAAA,CAAMP,QAAQ8F,MAAQ,EAAA;IACxB,OAAOnK,UAAW,CAAA4E,KAAA,CAAMP,OAAQ,CAAA8F,MAAA,CAAOqE,SAAS,CAAA;EAClD;EAEO,OAAA1P,UAAA;AACT,CAAA;AAEAqL,MAAO,CAAAH,OAAA,GAAU,gBAAgB5C,IAAA,EAAMxC,KAAO,EAAA;EACxC,IAAAA,KAAA,CAAMP,QAAQ8F,MAAQ,EAAA;IACxB,OAAOnK,UAAW,CAAA4E,KAAA,CAAMP,OAAQ,CAAA8F,MAAA,CAAOH,OAAO,CAAA;EAChD;EAEO,OAAAlL,UAAA;AACT,CAAA;AASO,MAAM2P,gBAAgE,CAAA,CAAC;AAE9EA,aAAA,CAAcC,QAAQ,eAAeA,KAAA,CAAMlI,IAAM,EAAAY,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EAG/D,MAAA,IAAA;EAEF,IAAA,CAAC2B,IAAK,CAAAtK,OAAA,EAAW,EAAA;IACZ,OAAA4C,UAAA;EACT;EAEA,MAAM6P,UAAU,EAAC;EACjB,MAAMC,aAAuB,EAAC;EAC9B,IAAIjJ,CAAI,GAAA,CAAA;EAER,KAAA,IAASkJ,UAAUzH,IAAM,EAAA;IACvB,IAAI0H,SAAY,GAAA,KAAA;IAEZ,IAAAD,MAAA,CAAO/S,SAAS,MAAQ,EAAA;MACdgT,SAAA,GAAA,MAAA;MACZD,MAAA,GAASA,MAAO,CAAArI,IAAA;IAAA,CAClB,MAAA,IAAWqI,MAAO,CAAA/S,IAAA,KAAS,KAAO,EAAA;MAChC+S,MAAA,GAASA,MAAO,CAAArI,IAAA;IAClB;IAEAmI,OAAA,CAAQzT,KAAK2T,MAAM,CAAA;IACnBD,UAAA,CAAW1T,KAAK4T,SAAS,CAAA;IACzBnJ,CAAA,EAAA;EACF;EAEA,MAAMoJ,MAAM,EAAC;EACb,IAAIC,GAAM,GAAA,CAAA;EAEV,WAAA,MAAiB3S,SAASmK,IAAM,EAAA;IACxB,MAAAQ,QAAA,GAAWpC,KAAM,CAAAJ,YAAA,CAAanI,KAAK,CAAA;IACzC,MAAM4S,QAAQ,CAAC,MAAM5S,KAAM,CAAAF,GAAA,IAAO6S,GAAG,CAAA;IACrC,KAAA,IAASxS,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAmJ,CAAA,EAAGnJ,CAAK,EAAA,EAAA;MAC1B,MAAMJ,MAAS,GAAA,MAAMyI,OAAQ,CAAA8J,OAAA,CAAQnS,IAAIwK,QAAQ,CAAA;MACjDiI,KAAA,CAAM/T,IAAK,CAAA,MAAMkB,MAAO,CAAAD,GAAA,EAAK,CAAA;IAC/B;IACA4S,GAAA,CAAI7T,KAAK+T,KAAK,CAAA;IACdD,GAAA,EAAA;EACF;EAEID,GAAA,CAAAG,IAAA,CAAK,CAACC,MAAA,EAAQC,MAAW,KAAA;IAC3B,KAAA,IAAS5S,CAAI,GAAA,CAAA,EAAGA,CAAI,GAAAmJ,CAAA,EAAGnJ,CAAK,EAAA,EAAA;MAC1B,IAAIqP,IAAIlJ,YAAa,CAAAwM,MAAA,CAAO3S,IAAI,CAAI,CAAA,EAAA4S,MAAA,CAAO5S,IAAI,CAAE,CAAA,CAAA;MAC7C,IAAAoS,UAAA,CAAWpS,OAAO,MAAQ,EAAA;QAC5BqP,CAAA,GAAI,CAACA,CAAA;MACP;MACA,IAAIA,MAAM,CAAG,EAAA;QACJ,OAAAA,CAAA;MACT;IACF;IAEO,OAAAsD,MAAA,CAAO,KAAKC,MAAO,CAAA,CAAA,CAAA;EAAA,CAC3B,CAAA;EAED,OAAOxQ,OAAOmQ,GAAI,CAAApN,GAAA,CAAKmH,CAAM,IAAAA,CAAA,CAAE,EAAE,CAAC,CAAA;AACpC,CAAA;AACA2F,aAAA,CAAcC,KAAM,CAAAlC,KAAA,GAASL,MAAAA,IAAUA,MAAS,IAAA,CAAA;AAGhDsC,aAAA,CAAc/C,QAAQ,eAAeA,KAAA,CAAMlF,IAAM,EAAAY,IAAA,EAAMxC,OAAOC,OAAS,EAAA;EACjE,IAAA,CAAC2B,KAAKtK,OAAQ,EAAA,EAAU,OAAA4C,UAAA;EAG5B,MAAMuQ,UAAsB,EAAC;EAC7B,MAAMC,SAAiC,EAAC;EAExC,WAAA,MAAiBjT,SAASmK,IAAM,EAAA;IAC1B,IAAAnK,KAAA,CAAMP,SAAS,QAAU,EAAA;MAC3BuT,OAAA,CAAQnU,IAAK,CAAA,MAAMmB,KAAM,CAAAF,GAAA,EAAK,CAAA;MAC9B;IACF;IAEM,MAAA6K,QAAA,GAAWpC,KAAM,CAAAJ,YAAA,CAAanI,KAAK,CAAA;IACrC,IAAAkT,UAAA,GAAa,OAAOlT,KAAM,CAAAJ,IAAA,CAAKuT,WAAW,QAAW,GAAAnT,KAAA,CAAMJ,KAAKuT,MAAS,GAAA,CAAA;IAE7E,KAAA,MAAW9C,OAAOtF,IAAM,EAAA;MACtBmI,UAAA,IAAc,MAAMpE,aAAA,CAAcuB,GAAK,EAAA1F,QAAA,EAAUnC,OAAO,CAAA;IAC1D;IAEM,MAAA4K,SAAA,GAAYnH,MAAO,CAAAK,MAAA,CAAO,CAAC,CAAA,EAAGtM,MAAMJ,IAAM,EAAA;MAACuT,MAAQ,EAAAD;IAAA,CAAW,CAAA;IACpED,MAAA,CAAOpU,KAAKuU,SAAS,CAAA;EACvB;EAEAH,MAAA,CAAOJ,KAAK,CAACvO,CAAA,EAAGC,MAAMA,CAAE,CAAA4O,MAAA,GAAS7O,EAAE6O,MAAM,CAAA;EACzC,OAAO5Q,OAAO0Q,MAAM,CAAA;AACtB,CAAA;AAEAb,aAAA,CAAc/C,KAAM,CAAAc,KAAA,GAASL,MAAAA,IAAUA,MAAS,IAAA,CAAA;AAIhD,MAAMuD,QAAqB,CAAA,CAAC;AAE5BA,KAAM,CAAAC,SAAA,GAAY,gBAAgBvI,IAAA,EAAMxC,KAAO,EAAA;EACvC,MAAAgL,SAAA,GAAYhL,KAAM,CAAAP,OAAA,CAAQgG,MAAW,KAAA,IAAA;EACrC,MAAAwF,QAAA,GAAWjL,KAAM,CAAAP,OAAA,CAAQ+F,KAAU,KAAA,IAAA;EAEzC,IAAIwF,aAAaC,QAAU,EAAA;IACzB,OAAO7P,WAAW,QAAQ,CAAA;EAC5B;EAEA,IAAI6P,QAAU,EAAA;IACZ,OAAO7P,WAAW,QAAQ,CAAA;EAC5B;EAEA,IAAI4P,SAAW,EAAA;IACb,OAAO5P,WAAW,QAAQ,CAAA;EAC5B;EAEO,OAAAlB,UAAA;AACT,CAAA;AAEA4Q,KAAA,CAAMI,aAAa,MAAM;EACjB,MAAA,IAAIjR,MAAM,iBAAiB,CAAA;AACnC,CAAA;AACA6Q,KAAA,CAAMI,WAAWtD,KAAQ,GAAA,CAAA;AACzBkD,KAAA,CAAMI,WAAWC,IAAO,GAAA,OAAA;AAExBL,KAAA,CAAMM,cAAc,MAAM;EAClB,MAAA,IAAInR,MAAM,iBAAiB,CAAA;AACnC,CAAA;AACA6Q,KAAA,CAAMM,YAAYxD,KAAQ,GAAA,CAAA;AAC1BkD,KAAA,CAAMM,YAAYD,IAAO,GAAA,OAAA;AAEzB,MAAME,OAAoB,CAAA,CAAC;AAC3BA,IAAA,CAAKH,aAAa,MAAM;EAChB,MAAA,IAAIjR,MAAM,iBAAiB,CAAA;AACnC,CAAA;AACAoR,IAAA,CAAKH,WAAWtD,KAAQ,GAAA,CAAA;AAExByD,IAAA,CAAKD,cAAc,MAAM;EACjB,MAAA,IAAInR,MAAM,iBAAiB,CAAA;AACnC,CAAA;AACAoR,IAAA,CAAKD,YAAYxD,KAAQ,GAAA,CAAA;AAEzB,MAAM0D,OAAoB,CAAA,CAAC;AAC3BA,IAAA,CAAKC,GAAM,GAAA,gBAAgB/I,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EAC/C,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EAEI,IAAA6G,CAAA;EACJ,WAAA,MAAiBoB,QAAQiH,GAAK,EAAA;IAC5B,IAAIjH,KAAKjL,IAAS,KAAA,MAAA,EAAQ;IACtB,IAAAiL,IAAA,CAAKjL,SAAS,QAAU,EAAA;MACnB,OAAAgD,UAAA;IACT;IACA,IAAI6G,CAAM,KAAA,KAAA,CAAA,IAAaoB,IAAK,CAAA9K,IAAA,GAAO0J,CAAG,EAAA;MACpCA,CAAA,GAAIoB,IAAK,CAAA9K,IAAA;IACX;EACF;EACA,OAAO2C,OAAO+G,CAAC,CAAA;AACjB,CAAA;AACAuK,IAAA,CAAKC,IAAI3D,KAAQ,GAAA,CAAA;AAEjB0D,IAAA,CAAKE,GAAM,GAAA,gBAAgBhJ,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EAC/C,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EAEI,IAAA6G,CAAA;EACJ,WAAA,MAAiBoB,QAAQiH,GAAK,EAAA;IAC5B,IAAIjH,KAAKjL,IAAS,KAAA,MAAA,EAAQ;IACtB,IAAAiL,IAAA,CAAKjL,SAAS,QAAU,EAAA;MACnB,OAAAgD,UAAA;IACT;IACA,IAAI6G,CAAM,KAAA,KAAA,CAAA,IAAaoB,IAAK,CAAA9K,IAAA,GAAO0J,CAAG,EAAA;MACpCA,CAAA,GAAIoB,IAAK,CAAA9K,IAAA;IACX;EACF;EACA,OAAO2C,OAAO+G,CAAC,CAAA;AACjB,CAAA;AACAuK,IAAA,CAAKE,IAAI5D,KAAQ,GAAA,CAAA;AAEjB0D,IAAA,CAAKG,GAAM,GAAA,gBAAgBjJ,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EAC/C,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EAEA,IAAI6G,CAAI,GAAA,CAAA;EACR,WAAA,MAAiBoB,QAAQiH,GAAK,EAAA;IAC5B,IAAIjH,KAAKjL,IAAS,KAAA,MAAA,EAAQ;IACtB,IAAAiL,IAAA,CAAKjL,SAAS,QAAU,EAAA;MACnB,OAAAgD,UAAA;IACT;IACA6G,CAAA,IAAKoB,IAAK,CAAA9K,IAAA;EACZ;EACA,OAAO2C,OAAO+G,CAAC,CAAA;AACjB,CAAA;AACAuK,IAAA,CAAKG,IAAI7D,KAAQ,GAAA,CAAA;AAEjB0D,IAAA,CAAKI,GAAM,GAAA,gBAAgBlJ,IAAM,EAAAxC,KAAA,EAAOC,OAAS,EAAA;EAC/C,MAAMmJ,GAAM,GAAA,MAAMnJ,OAAQ,CAAAuC,IAAA,CAAK,IAAIxC,KAAK,CAAA;EACpC,IAAA,CAACoJ,GAAI,CAAA9R,OAAA,EAAW,EAAA;IACX,OAAA4C,UAAA;EACT;EAEA,IAAI6G,CAAI,GAAA,CAAA;EACR,IAAIkG,CAAI,GAAA,CAAA;EACR,WAAA,MAAiB9E,QAAQiH,GAAK,EAAA;IAC5B,IAAIjH,KAAKjL,IAAS,KAAA,MAAA,EAAQ;IACtB,IAAAiL,IAAA,CAAKjL,SAAS,QAAU,EAAA;MACnB,OAAAgD,UAAA;IACT;IACA6G,CAAA,IAAKoB,IAAK,CAAA9K,IAAA;IACV4P,CAAA,EAAA;EACF;EACA,IAAIA,MAAM,CAAG,EAAA;IACJ,OAAA/M,UAAA;EACT;EACO,OAAAF,MAAA,CAAO+G,IAAIkG,CAAC,CAAA;AACrB,CAAA;AACAqE,IAAA,CAAKI,IAAI9D,KAAQ,GAAA,CAAA;AAEV,MAAM+D,UAA2B,GAAA;EACtCC,MAAQ,EAAAlE,OAAA;EACR3R,MAAAA,EAAAA,OAAAA;EACAiN,KAAA;EACA2G,EAAA;EACAmB,KAAA;EACAO,IAAA;EACA9F,MAAA;EACA+F;AACF,CAAA;ACtlBO,MAAMO,aAAc,CAAA;EAOzBnV,WAAA,CAAYX,MAAgB,EAAA+V,KAAA,EAAeC,YAA4B,EAAA;IAF1D,IAAA,CAAAC,UAAA,GAAA,KAAA;IAGX,IAAA,CAAKjW,MAAS,GAAAA,MAAA;IACd,IAAA,CAAK+V,KAAQ,GAAAA,KAAA;IACb,IAAA,CAAKjJ,KAAQ,GAAA,CAAA;IACb,IAAA,CAAKkJ,YAAe,GAAAA,YAAA;EACtB;EAEAE,OAAA,GAA0B;IAAA,IAAlBC,0EAAM,CAAY;IACxB,OAAO,IAAK,CAAArJ,KAAA,GAAQqJ,GAAM,GAAA,IAAA,CAAKJ,KAAM,CAAAjU,MAAA;EACvC;EAEAsU,OAAA,GAAuB;IAAA,IAAfD,0EAAM,CAAS;IACd,OAAA,IAAA,CAAKJ,KAAM,CAAA,IAAA,CAAKjJ,KAAQ,GAAAqJ,GAAA,CAAA;EACjC;EAEAE,KAAc,GAAA;IACZ,IAAA,CAAKvJ,KAAS,IAAA,CAAA;EAChB;EAEAwJ,QAAWC,OAA4B,EAAA;IAC/B,MAAAC,IAAA,GAAO,IAAK,CAAAT,KAAA,CAAM,IAAK,CAAAjJ,KAAA,CAAA;IAC7B,IAAA,CAAKuJ,KAAM,EAAA;IACL,MAAAlM,IAAA,GAAOoM,QAAQC,IAAK,CAAA5L,IAAA,CAAA;IAC1B,IAAI,CAACT,IAAM,EAAA;MACT,MAAM,IAAIjG,KAAA,4BAA0BsS,IAAA,CAAK5L,IAAM,EAAA;IACjD;IACA,OAAOT,IAAK,CAAAsM,IAAA,CAAKF,OAAS,EAAA,IAAA,EAAMC,IAAI,CAAA;EACtC;EAEAE,aAAwB,GAAA;IACtB,IAAA,CAAKL,KAAM,EAAA;IACX,OAAO,KAAKM,gBAAiB,EAAA;EAC/B;EAEAA,gBAA2B,GAAA;IACzB,MAAMC,IAAO,GAAA,IAAA,CAAKb,KAAM,CAAA,IAAA,CAAKjJ,KAAQ,GAAA,CAAA,CAAA;IAC/B,MAAA+J,IAAA,GAAO,IAAK,CAAAd,KAAA,CAAM,IAAK,CAAAjJ,KAAA,CAAA;IAC7B,IAAA,CAAKuJ,KAAM,EAAA;IACX,OAAO,KAAKrW,MAAO,CAAAqH,KAAA,CAAMuP,IAAK,CAAAE,QAAA,EAAUD,KAAKC,QAAQ,CAAA;EACvD;EAEAzP,MAAM0P,GAAqB,EAAA;IACzB,MAAMZ,GAAM,GAAA,IAAA,CAAKJ,KAAM,CAAA,IAAA,CAAKjJ,KAAO,CAAA,CAAAgK,QAAA;IACnC,OAAO,IAAK,CAAA9W,MAAA,CAAOqH,KAAM,CAAA8O,GAAA,EAAKA,MAAMY,GAAG,CAAA;EACzC;AACF;AC5GA,MAAMC,EAAK,GAAA,8CAAA;AACX,MAAMC,GAAM,GAAA,MAAA;AACZ,MAAMC,KAAQ,GAAA,yBAAA;AAGd,MAAMC,SAAY,GAAA,CAAA;AAClB,MAAMC,OAAU,GAAA,CAAA;AAChB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,SAAY,GAAA,CAAA;AAClB,MAAMC,UAAa,GAAA,CAAA;AACnB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AAGjB,MAAMC,QAAW,GAAA,EAAA;AACjB,MAAMC,QAAW,GAAA,EAAA;AACjB,MAAMC,QAAW,GAAA,CAAA;AAEjB,SAASC,QAAMnX,GAAK,EAAA;EAClB,IAAIqV,GAAM,GAAA,CAAA;EACJA,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;EACrB,IAAI1U,MAAS,GAAA0W,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;EAClC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;EAC9B0U,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAW,MAAA,CAAOqV,QAAQ,CAAA;EAC7B,IAAAX,GAAA,KAAQrV,IAAIgB,MAAQ,EAAA;IACtB,IAAIL,OAAO2W,YAAc,EAAA;MACvBjC,GAAA,GAAM1U,OAAO2W,YAAe,GAAA,CAAA;IAC9B;IACA,OAAO;MAACjX,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;EACtC;EACA,OAAO1U,MAAO,CAAAqV,QAAA;EACd,OAAOrV,MAAO,CAAA2W,YAAA;EACP,OAAA3W,MAAA;AACT;AAEA,SAAS0W,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAKkC,KAAO,EAAA;EAkBlC,IAAIC,QAAW,GAAAnC,GAAA;EACf,IAAIjP,QAAQpG,GAAI,CAAAqV,GAAA,CAAA;EACZ,IAAAJ,KAAA;EAEI,QAAA7O,KAAA;IAAA,KACD,GAAK;MAAA;QACJ,IAAAqR,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqV,GAAM,GAAA,CAAC,GAAG2B,QAAQ,CAAA;QACvD,IAAIS,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;QACzBxC,KAAA,GAAA,CAAC;UAACnL,IAAA,EAAM,KAAO;UAAAkM,QAAA,EAAUwB;QAAS,CAAA,CAAA,CAAExP,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;QAC5DI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;QACV;MACF;IAAA,KACK,GAAK;MAAA;QACJ,IAAAyB,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqV,GAAM,GAAA,CAAC,GAAG6B,QAAQ,CAAA;QACvD,IAAIO,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;QACzBxC,KAAA,GAAA,CAAC;UAACnL,IAAA,EAAM,KAAO;UAAAkM,QAAA,EAAUwB;QAAS,CAAA,CAAA,CAAExP,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;QAC5DI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;QACV;MACF;IAAA,KACK,GAAK;MAAA;QACJ,IAAAyB,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqV,GAAM,GAAA,CAAC,GAAG,CAAC,CAAA;QAChD,IAAIoC,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;QAC3BpC,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAyX,GAAA,CAAIzB,QAAQ,CAAA;QAC9B,QAAQhW,GAAI,CAAAqV,GAAA,CAAA;UAAA,KACL,GAAK;YAAA;cAEAJ,KAAA,GAAA,CAAC;gBAACnL,IAAA,EAAM,OAAS;gBAAAkM,QAAA,EAAUwB;cAAS,CAAA,CAAA,CAAExP,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;cACxDI,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;cACzB,OAAO,IAAM,EAAA;gBACLoC,GAAA,GAAAJ,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;gBAC3B,IAAIoC,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;gBAC3BpC,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAyX,GAAA,CAAIzB,QAAQ,CAAA;gBAC9B,IAAIhW,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;gBAChBA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;cAC3B;cACA,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK,OAAO;gBAAChV,IAAA,EAAM,OAAS;gBAAA2V,QAAA,EAAUX;cAAG,CAAA;cAC1DA,GAAA,EAAA;cACAJ,KAAA,CAAMxV,KAAK;gBAACqK,IAAA,EAAM,WAAa;gBAAAkM,QAAA,EAAUX;eAAI,CAAA;cAC7C;YACF;UAAA,KACK,GAAK;YAAA;cACRA,GAAA,EAAA;cACQJ,KAAA,GAAA,CAAC;gBAACnL,IAAA,EAAM,OAAS;gBAAAkM,QAAA,EAAUwB;cAAS,CAAA,CAAA,CAAExP,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;cAC9D;YACF;UAAA;YAEE,OAAO;cAAC5U,IAAA,EAAM,OAAS;cAAA2V,QAAA,EAAUX;YAAG,CAAA;QAAA;QAExC;MACF;IAAA,KACK,GAAK;MAAA;QACJ,IAAAoC,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqV,GAAM,GAAA,CAAC,GAAG4B,QAAQ,CAAA;QACvD,IAAIQ,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;QACzBxC,KAAA,GAAA,CAAC;UAACnL,IAAA,EAAM,KAAO;UAAAkM,QAAA,EAAUwB;QAAS,CAAA,CAAA,CAAExP,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;QAC5DI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;QACV;MACF;IAAA,KACK,GAAK;MAAA;QACJ,IAAArV,MAAA,GAAS+W,WAAY,CAAA1X,GAAA,EAAKqV,GAAG,CAAA;QACjC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;QACpCsU,KAAA,GAAQtU,MAAO,CAAAsU,KAAA;QACfI,GAAA,GAAM1U,MAAO,CAAAqV,QAAA;QACb;MACF;IACK,KAAA,GAAA;MACHf,KAAA,GAAQ,CAAC;QAACnL,IAAA,EAAM,OAAS;QAAAkM,QAAA,EAAUX;OAAI,CAAA;MACjCA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;MAErB,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;QACpB,OAAO,IAAM,EAAA;UACX,IAAIrV,IAAIuG,KAAM,CAAA8O,GAAA,EAAKA,GAAM,GAAA,CAAC,MAAM,KAAO,EAAA;YACrCJ,KAAA,CAAMxV,KAAK;cAACqK,IAAA,EAAM,aAAe;cAAAkM,QAAA,EAAUX;aAAI,CAAA;YACzCA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;UAC3B;UAEA,IAAIrF,GAAM,GAAAqH,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;UAC/B,IAAIrF,IAAI3P,IAAS,KAAA,OAAA,EAAgB,OAAA2P,GAAA;UACzBiF,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAgI,GAAA,CAAIiF,KAAK,CAAA;UAC9BI,GAAA,GAAMrF,GAAI,CAAAgG,QAAA;UACJX,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;UACrB,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;UAChBA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;UACzB,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;QACxB;MACF;MAEI,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;QACpBA,GAAA,EAAA;QACAJ,KAAA,CAAMxV,KAAK;UAACqK,IAAA,EAAM,WAAa;UAAAkM,QAAA,EAAUX;SAAI,CAAA;MAAA,CACxC,MAAA;QACL,OAAO;UAAChV,IAAA,EAAM,OAAS;UAAA2V,QAAA,EAAUX;QAAG,CAAA;MACtC;MAEA;IACG,KAAA,GAAA;IAAA,KACA,GAAK;MAAA;QACJ,IAAA1U,MAAA,GAASgX,WAAY,CAAA3X,GAAA,EAAKqV,GAAG,CAAA;QACjC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;QACpCsU,KAAA,GAAQtU,MAAO,CAAAsU,KAAA;QACfI,GAAA,GAAM1U,MAAO,CAAAqV,QAAA;QACb;MACF;IAAA,KACK,GAAK;MAAA;QACRX,GAAA,EAAA;QACAJ,KAAA,GAAQ,EAAC;QACT,OAAOjV,IAAIqV,GAAS,CAAA,KAAA,GAAA,IAAOrV,GAAI,CAAAqV,GAAA,GAAM,OAAO,GAAK,EAAA;UAC/CJ,KAAA,CAAMxV,KAAK;YAACqK,IAAA,EAAM,WAAa;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC3CnC,GAAA,IAAA,CAAA;QACT;QACAJ,KAAA,CAAMxV,KAAK;UAACqK,IAAA,EAAM,QAAU;UAAAkM,QAAA,EAAUwB;SAAS,CAAA;QAC/C;MACF;IACK,KAAA,GAAA;MACHvC,KAAA,GAAQ,CAAC;QAACnL,IAAA,EAAM,MAAQ;QAAAkM,QAAA,EAAUwB;OAAS,CAAA;MAC3CnC,GAAA,EAAA;MACA;IACG,KAAA,GAAA;MACHJ,KAAA,GAAQ,CAAC;QAACnL,IAAA,EAAM,YAAc;QAAAkM,QAAA,EAAUwB;OAAS,CAAA;MACjDnC,GAAA,EAAA;MACA;IAAA,KACG,GAAK;MAAA;QACR,IAAIuC,QAAW,GAAAC,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,GAAM,GAAGe,KAAK,CAAA;QAC7C,IAAIwB,QAAU,EAAA;UACZvC,GAAA,IAAO,CAAI,GAAAuC,QAAA;UACH3C,KAAA,GAAA,CACN;YAACnL,IAAA,EAAM,OAAS;YAAAkM,QAAA,EAAUwB;UAAQ,CAAA,EAClC;YAAC1N,IAAA,EAAM,OAAS;YAAAkM,QAAA,EAAUwB,WAAW;UAAC,CAAA,EACtC;YAAC1N,IAAA,EAAM,WAAa;YAAAkM,QAAA,EAAUX;UAAG,CAAA,CACnC;QACF;QACA;MACF;IACS;MAAA;QACP,IAAIyC,MAAS,GAAAD,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKc,GAAG,CAAA;QACrC,IAAI2B,MAAQ,EAAA;UACHzC,GAAA,IAAAyC,MAAA;UACP,IAAIhO,IAAO,GAAA,SAAA;UAEP,IAAA9J,GAAA,CAAIqV,SAAS,GAAK,EAAA;YACpB,IAAI0C,OAAU,GAAAF,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,GAAM,GAAGc,GAAG,CAAA;YAC1C,IAAI4B,OAAS,EAAA;cACJjO,IAAA,GAAA,OAAA;cACPuL,GAAA,IAAO,CAAI,GAAA0C,OAAA;YACb;UACF;UAEA,IAAI/X,GAAI,CAAAqV,GAAA,CAAA,KAAS,GAAO,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;YACjCvL,IAAA,GAAA,KAAA;YACPuL,GAAA,EAAA;YACA,IAAIrV,GAAI,CAAAqV,GAAA,CAAA,KAAS,GAAO,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;cACxCA,GAAA,EAAA;YACF;YACA,IAAI2C,MAAS,GAAAH,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKc,GAAG,CAAA;YACrC,IAAI,CAAC6B,MAAA,EAAQ,OAAO;cAAC3X,IAAA,EAAM,OAAS;cAAA2V,QAAA,EAAUX;YAAG,CAAA;YAC1CA,GAAA,IAAA2C,MAAA;UACT;UAEQ/C,KAAA,GAAA,CACN;YAACnL,IAAM;YAAAkM,QAAA,EAAUwB;UAAQ,CAAA,EACzB;YAAC1N,IAAA,EAAMA,IAAO,GAAA,MAAA;YAAQkM,UAAUX;UAAG,CAAA,CACrC;UAEA;QACF;QAEA,IAAIuC,QAAW,GAAAC,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKe,KAAK,CAAA;QACzC,IAAIwB,QAAU,EAAA;UACLvC,GAAA,IAAAuC,QAAA;UACP,QAAQ5X,GAAI,CAAAqV,GAAA,CAAA;YACL,KAAA,GAAA;YAAA,KACA,GAAK;cAAA;gBACR,IAAI1U,MAAS,GAAAsX,aAAA,CAAcjY,GAAK,EAAAwX,QAAA,EAAUnC,GAAG,CAAA;gBAC7C,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;gBACpCsU,KAAA,GAAQtU,MAAO,CAAAsU,KAAA;gBACfI,GAAA,GAAM1U,MAAO,CAAAqV,QAAA;gBACb;cACF;YACS;cAAA;gBACCf,KAAA,GAAA,CACN;kBAACnL,IAAA,EAAM,WAAa;kBAAAkM,QAAA,EAAUwB;gBAAQ,CAAA,EACtC;kBAAC1N,IAAA,EAAM,OAAS;kBAAAkM,QAAA,EAAUwB;gBAAQ,CAAA,EAClC;kBAAC1N,IAAA,EAAM,WAAa;kBAAAkM,QAAA,EAAUX;gBAAG,CAAA,CACnC;cACF;UAAA;UAGF;QACF;MACF;EAAA;EAGF,IAAI,CAACJ,KAAO,EAAA;IACV,OAAO;MAAC5U,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;EACtC;EAEA,IAAI6C,QAAW,GAAA,EAAA;EACX,IAAAC,IAAA;EAEJC,IAAA,EAAM,OAAO,IAAM,EAAA;IACb,IAAAC,QAAA,GAAWjB,MAAO,CAAApX,GAAA,EAAKqV,GAAG,CAAA;IAC1B,IAAAgD,QAAA,KAAarY,IAAIgB,MAAQ,EAAA;MACrBqU,GAAA,GAAAgD,QAAA;MACN;IACF;IAEOF,IAAA,GAAAG,cAAA,CAAetY,KAAKqY,QAAQ,CAAA;IAC/B,IAAAF,IAAA,CAAK9X,SAAS,SAAW,EAAA;MAC3B4U,KAAA,CAAMsD,QAAQ;QAACzO,IAAA,EAAM,UAAY;QAAAkM,QAAA,EAAUwB;OAAS,CAAA;MAC7C,OAAAW,IAAA,CAAK9X,SAAS,SAAW,EAAA;QACtB4U,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAmQ,IAAA,CAAKlD,KAAK,CAAA;QAC/BI,GAAA,GAAM8C,IAAK,CAAAnC,QAAA;QACXmC,IAAA,GAAOG,cAAe,CAAAtY,GAAA,EAAKoX,MAAO,CAAApX,GAAA,EAAKqV,GAAG,CAAC,CAAA;MAC7C;MACAJ,KAAA,CAAMxV,KAAK;QAACqK,IAAA,EAAM,eAAiB;QAAAkM,QAAA,EAAUX;OAAI,CAAA;MACjD;IACF;IAEA,IAAIjP,SAAQpG,GAAI,CAAAqY,QAAA,CAAA;IACRjS,QAAAA,MAAAA;MAAA,KACD,GAAK;QAAA;UACJ,IAAAoS,SAAA,GAAYxY,IAAIqY,QAAW,GAAA,CAAA,CAAA;UACvB,QAAAG,SAAA;YAAA,KACD,GAAK;cAAA;gBAEJ,IAAAjB,KAAA,GAAQlB,aAAa6B,QAAY,IAAA7B,SAAA,EAAiB,MAAA+B,IAAA;gBAClD,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,GAAGhC,SAAS,CAAA;gBAC7D,IAAIoB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;gBACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;gBAC9BA,KAAA,CAAMsD,QAAQ;kBAACzO,IAAA,EAAM,MAAQ;kBAAAkM,QAAA,EAAUwB;iBAAS,CAAA;gBAChDnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;gBACCkC,QAAA,GAAA7B,SAAA;gBACX;cACF;YAAA,KACK,GAAK;cAAA;gBAEJ,IAAAkB,KAAA,GAAQf,aAAa0B,QAAY,IAAA1B,SAAA,EAAiB,MAAA4B,IAAA;gBAClD,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,GAAG,CAAC,CAAA;gBACrD,IAAIZ,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;gBACjCxC,KAAA,CAAMsD,QAAQ;kBAACzO,IAAA,EAAM,MAAQ;kBAAAkM,QAAA,EAAUwB;iBAAS,CAAA;gBAChDvC,KAAA,CAAMxV,IAAK,CAAA;kBAACqK,IAAM,EAAA,IAAA;kBAAMkM,QAAU,EAAAqC;gBAAA,CAAW,EAAA;kBAACvO,IAAM,EAAA,QAAA;kBAAUkM,QAAU,EAAAqC,QAAA,GAAW;gBAAE,CAAA,CAAA;gBAC7EpD,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;gBAC9BI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;gBACCkC,QAAA,GAAA1B,SAAA;gBACX;cACF;YAAA;cAEQ,MAAA4B,IAAA;UAAA;UAEV;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAAb,KAAA,GAAQb,YAAYwB,QAAW,GAAAxB,QAAA,EAAgB,MAAA0B,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA3B,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIe,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAAxB,QAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAAa,KAAA,GAAQZ,YAAYuB,QAAW,GAAAvB,QAAA,EAAgB,MAAAyB,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA1B,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIc,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAAvB,QAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAA3W,GAAA,CAAIqY,QAAW,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;YAEzB,IAAAd,KAAA,GAAQR,YAAYmB,QAAY,IAAAnB,QAAA,EAAgB,MAAAqB,IAAA;YAChDX,IAAAA,IAAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,GAAGtB,QAAQ,CAAA;YAC5D,IAAIU,KAAIpX,IAAS,KAAA,OAAA,EAAgBoX,OAAAA,IAAAA;YACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAOyP,CAAAA,IAAAA,CAAIxC,KAAK,CAAA;YAC9BA,KAAA,CAAMsD,QAAQ;cAACzO,IAAA,EAAM,KAAO;cAAAkM,QAAA,EAAUwB;aAAS,CAAA;YAC/CnC,GAAA,GAAMoC,IAAI,CAAAzB,QAAA;YACCkC,QAAA,GAAAnB,QAAA;YACX;UACF;UAGI,IAAAQ,KAAA,GAAQX,YAAYsB,QAAW,GAAAtB,QAAA,EAAgB,MAAAwB,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAAzB,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIa,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAAtB,QAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAAW,KAAA,GAAQV,YAAYqB,QAAW,GAAArB,QAAA,EAAgB,MAAAuB,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAAxB,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIY,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAArB,QAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAAU,KAAA,GAAQT,YAAYoB,QAAW,GAAApB,QAAA,EAAgB,MAAAsB,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAAvB,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIW,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAApB,QAAA;UACX;QACF;MACK,KAAA,GAAA;MAAA,KACA,GAAK;QAAA;UACJ,IAAAS,KAAA,GAAQf,aAAa0B,QAAY,IAAA1B,SAAA,EAAiB,MAAA4B,IAAA;UACtD,IAAIK,UAAUJ,QAAW,GAAA,CAAA;UACrB,IAAArY,GAAA,CAAIyY,aAAa,GAAK,EAAA;YACxBA,OAAA,EAAA;UACF;UACI,IAAAhB,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKyY,OAAO,CAAA,EAAGjC,YAAY,CAAC,CAAA;UAC5D,IAAIiB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACjCxC,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,MAAQ;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAChDvC,KAAA,CAAMxV,IAAK,CAAA;YAACqK,IAAM,EAAA,IAAA;YAAMkM,QAAU,EAAAqC;WAAW,EAAA;YAACvO,IAAM,EAAA,QAAA;YAAUkM,QAAU,EAAAyC;UAAQ,CAAA,CAAA;UACxExD,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAA1B,SAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UACJ,IAAAxW,GAAA,CAAIqY,QAAW,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;YAEzB,IAAAd,KAAA,GAAQjB,WAAW4B,QAAW,GAAA5B,OAAA,EAAe,MAAA8B,IAAA;YAC7C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA/B,OAAA,GAAU,CAAC,CAAA;YAC/D,IAAImB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;YACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;YAC9BA,KAAA,CAAMsD,QAAQ;cAACzO,IAAA,EAAM,IAAM;cAAAkM,QAAA,EAAUwB;aAAS,CAAA;YAC9CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;YACCkC,QAAA,GAAA5B,OAAA;UAAA,CACN,MAAA;YACD,IAAAiB,KAAA,GAAQ,MAAMW,QAAW,GAAA,EAAA,EAAU,MAAAE,IAAA;YAEvC,IAAIM,QAAW,GAAAtB,MAAA,CAAOpX,GAAK,EAAAqY,QAAA,GAAW,CAAC,CAAA;YACvC,IAAIT,QAAW,GAAAC,UAAA,CAAW7X,GAAK,EAAA0Y,QAAA,EAAUtC,KAAK,CAAA;YAC9C,IAAI,CAACwB,QAAA,EAAU,OAAO;cAACvX,IAAA,EAAM,OAAS;cAAA2V,QAAA,EAAU0C;YAAQ,CAAA;YACxDrD,GAAA,GAAMqD,QAAW,GAAAd,QAAA;YACjB,IAAI5X,GAAI,CAAAqV,GAAA,CAAA,KAAS,GAAO,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;cACxC,IAAI1U,MAAS,GAAAsX,aAAA,CAAcjY,GAAK,EAAA0Y,QAAA,EAAUrD,GAAG,CAAA;cAC7C,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;cAC5BsU,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAArH,MAAA,CAAOsU,KAAK,CAAA;cACjCA,KAAA,CAAMsD,QAAQ;gBAACzO,IAAA,EAAM,UAAY;gBAAAkM,QAAA,EAAUwB;eAAS,CAAA;cACpDnC,GAAA,GAAM1U,MAAO,CAAAqV,QAAA;cACFkC,QAAA,GAAA,EAAA;YACb;UACF;UACA;QACF;MAAA,KACK,GAAK;QAAA;UAEJ,IAAAlY,GAAA,CAAIqY,WAAW,CAAM,CAAA,IAAA,GAAA,EAAW,MAAAD,IAAA;UAChC,IAAAb,KAAA,GAAQhB,YAAY2B,QAAW,GAAA3B,QAAA,EAAgB,MAAA6B,IAAA;UAC/C,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA9B,QAAA,GAAW,CAAC,CAAA;UAChE,IAAIkB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACzBxC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BA,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAA3B,QAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UAEJ,IAAAvW,GAAA,CAAIqY,WAAW,CAAO,CAAA,KAAA,GAAA,EAAW,MAAAD,IAAA;UACjC,IAAAb,KAAA,GAAQf,aAAa0B,QAAW,GAAA1B,SAAA,EAAiB,MAAA4B,IAAA;UACjD,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA7B,SAAA,GAAY,CAAC,CAAA;UACjE,IAAIiB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UACjCxC,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,MAAQ;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAChDvC,KAAA,CAAMxV,IAAK,CAAA;YAACqK,IAAM,EAAA,IAAA;YAAMkM,QAAU,EAAAqC;UAAA,CAAW,EAAA;YAACvO,IAAM,EAAA,QAAA;YAAUkM,QAAU,EAAAqC,QAAA,GAAW;UAAE,CAAA,CAAA;UAC7EpD,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;UAC9BI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;UACCkC,QAAA,GAAA1B,SAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UAER,IAAIxW,GAAI,CAAAuG,KAAA,CAAM8R,QAAU,EAAAA,QAAA,GAAW,CAAC,CAAM,KAAA,MAAA,EAAc,MAAAD,IAAA;UACpD,IAAAb,KAAA,GAAQd,cAAcyB,QAAW,GAAAzB,UAAA,EAAkB,MAAA2B,IAAA;UACvDnD,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,MAAQ;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAChDnC,GAAA,GAAMgD,QAAW,GAAA,CAAA;UACNH,QAAA,GAAAzB,UAAA;UACX;QACF;MAAA,KACK,GAAK;QAAA;UAER,IAAIzW,GAAI,CAAAuG,KAAA,CAAM8R,QAAU,EAAAA,QAAA,GAAW,CAAC,CAAM,KAAA,KAAA,EAAa,MAAAD,IAAA;UACnD,IAAAb,KAAA,GAAQd,cAAcyB,QAAW,GAAAzB,UAAA,EAAkB,MAAA2B,IAAA;UACvDnD,KAAA,CAAMsD,QAAQ;YAACzO,IAAA,EAAM,KAAO;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UAC/CnC,GAAA,GAAMgD,QAAW,GAAA,CAAA;UACNH,QAAA,GAAAzB,UAAA;UACX;QACF;MACS;QAAA;UACP,IAAIkC,KAAQ,GAAAC,aAAA,CAAc5Y,GAAK,EAAAqY,QAAA,EAAUjC,KAAK,CAAA;UACtC,QAAAuC,KAAA;YAAA,KACD,IAAM;cAAA;gBACL,IAAApB,KAAA,GAAQf,aAAa0B,QAAY,IAAA1B,SAAA,EAAiB,MAAA4B,IAAA;gBAEhD/C,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqY,QAAA,GAAW,CAAC,CAAA;gBAE9B,IAAIQ,OAAU,GAAA,KAAA;gBAEV,IAAA7Y,GAAA,CAAIqV,SAAS,GAAK,EAAA;kBACVwD,OAAA,GAAA,IAAA;kBACJxD,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;gBAC3B;gBAEA,IAAIyD,QAAW,GAAAzD,GAAA;gBACf,IAAI1U,MAAS,GAAA0W,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAKmB,YAAY,CAAC,CAAA;gBAC9C,IAAI7V,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;gBAE9B0U,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAW,MAAA,CAAOqV,QAAQ,CAAA;gBAEjC,IAAIhW,IAAIqV,GAAS,CAAA,KAAA,GAAA,IAAOrV,GAAI,CAAAqV,GAAA,GAAM,OAAO,GAAK,EAAA;kBAE5C,IAAIhV,IAAO,GAAA,WAAA;kBACP,IAAAL,GAAA,CAAIqV,GAAM,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;oBACjBhV,IAAA,GAAA,WAAA;oBACDgV,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;kBAAA,CACpB,MAAA;oBACCA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;kBAC3B;kBAEA,IAAIoC,GAAM,GAAAJ,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAKmB,YAAY,CAAC,CAAA;kBAC3C,IAAIiB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;kBACjCxC,KAAA,CAAMsD,QAAQ;oBAACzO,IAAA,EAAM,UAAY;oBAAAkM,QAAA,EAAUwB;mBAAS,CAAA;kBAC5CvC,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAA;oBAAC8B,IAAM,EAAAzJ,IAAA;oBAAM2V,QAAU,EAAA8C;kBAAA,CAAW,EAAAnY,MAAA,CAAOsU,KAAO,EAAAwC,GAAA,CAAIxC,KAAK,CAAA;kBAC9EI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;gBAAA,CACL,MAAA;kBAELf,KAAA,CAAMsD,QAAQ;oBAACzO,IAAA,EAAM,MAAQ;oBAAAkM,QAAA,EAAUwB;mBAAS,CAAA;kBAChDvC,KAAA,CAAMxV,IAAK,CAAA;oBAACqK,IAAM,EAAA,IAAA;oBAAMkM,QAAU,EAAAqC;kBAAA,CAAW,EAAA;oBAACvO,IAAM,EAAA,QAAA;oBAAUkM,QAAU,EAAAqC,QAAA,GAAW;kBAAE,CAAA,CAAA;kBAC7EpD,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAArH,MAAA,CAAOsU,KAAK,CAAA;gBACnC;gBAEA,IAAI4D,OAAS,EAAA;kBACLxD,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;kBACrB,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK,OAAO;oBAAChV,IAAA,EAAM,OAAS;oBAAA2V,QAAA,EAAUX;kBAAG,CAAA;kBAC1DA,GAAA,EAAA;gBACF;gBAEW6C,QAAA,GAAA1B,SAAA;gBACX;cACF;YAAA,KACK,OAAS;cAAA;gBAER,IAAAe,KAAA,GAAQf,aAAa0B,QAAY,IAAA1B,SAAA,EAAiB,MAAA4B,IAAA;gBAClD,IAAAX,GAAA,GAAMJ,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKqY,QAAW,GAAA,CAAC,CAAG,EAAA7B,SAAA,GAAY,CAAC,CAAA;gBACjE,IAAIiB,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;gBACjCxC,KAAA,CAAMsD,QAAQ;kBAACzO,IAAA,EAAM,MAAQ;kBAAAkM,QAAA,EAAUwB;iBAAS,CAAA;gBAChDvC,KAAA,CAAMxV,IAAK,CAAA;kBAACqK,IAAM,EAAA,IAAA;kBAAMkM,QAAU,EAAAqC;gBAAA,CAAW,EAAA;kBAACvO,IAAM,EAAA,QAAA;kBAAUkM,QAAU,EAAAqC,QAAA,GAAW;gBAAE,CAAA,CAAA;gBAC7EpD,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAyP,GAAA,CAAIxC,KAAK,CAAA;gBAC9BI,GAAA,GAAMoC,GAAI,CAAAzB,QAAA;gBACCkC,QAAA,GAAA,CAAA;gBACX;cACF;YACS;cAAA;gBACD,MAAAE,IAAA;cACR;UAAA;QAEJ;IAAA;EAEJ;EAEA,IAAId,YAAe,GAAA,CAAAa,IAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,IAAA,CAAM9X,IAAS,MAAA,OAAA,IAAW8X,IAAK,CAAAnC,QAAA;EAElD,OAAO;IAAC3V,IAAM,EAAA,SAAA;IAAW4U,KAAO;IAAAe,QAAA,EAAUX;IAAKiC;GAAY;AAC7D;AAEA,SAASgB,cAAA,CAAetY,KAAKqV,GAAK,EAAA;EAChC,IAAImC,QAAW,GAAAnC,GAAA;EACf,QAAQrV,GAAI,CAAAqV,GAAA,CAAA;IAAA,KACL,GAAK;MAAA;QACFA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;QACzB,IAAI0D,UAAa,GAAA1D,GAAA;QACjB,IAAIuC,SAAW,GAAAC,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKe,KAAK,CAAA;QACzC,IAAI,CAACwB,SAAAA,EAAU,OAAO;UAACvX,IAAA,EAAM,OAAS;UAAA2V,QAAA,EAAUX;QAAG,CAAA;QAC5CuC,GAAAA,IAAAA,SAAAA;QAEA,OAAA;UACLvX,IAAM,EAAA,SAAA;UACN4U,KAAO,EAAA,CACL;YAACnL,IAAA,EAAM,aAAe;YAAAkM,QAAA,EAAUwB;UAAQ,CAAA,EACxC;YAAC1N,IAAA,EAAM,OAAS;YAAAkM,QAAA,EAAU+C;UAAU,CAAA,EACpC;YAACjP,IAAA,EAAM,WAAa;YAAAkM,QAAA,EAAUX;UAAG,CAAA,CACnC;UACAW,QAAU,EAAAX;QAAA,CACZ;MACF;IACK,KAAA,GAAA;MACC,IAAArV,GAAA,CAAIqV,MAAM,CAAO,CAAA,KAAA,GAAA,EAAK,OAAO;QAAChV,IAAA,EAAM,OAAS;QAAA2V,QAAA,EAAUX;MAAG,CAAA;MAG9D,IAAIJ,QAAQ,CAAC;QAACnL,MAAM,OAAS;QAAAkM,QAAA,EAAUwB;OAAS,CAAA;MACzCnC,GAAA,IAAA,CAAA;MAEH,IAAAqD,QAAA,GAAWtB,MAAO,CAAApX,GAAA,EAAKqV,GAAG,CAAA;MAC9B,IAAIuC,QAAW,GAAAC,UAAA,CAAW7X,GAAK,EAAA0Y,QAAA,EAAUtC,KAAK,CAAA;MAC9C,IAAIwB,QAAU,EAAA;QACZvC,GAAA,GAAMqD,QAAW,GAAAd,QAAA;QACX3C,KAAA,CAAAxV,IAAA,CACJ;UAACqK,IAAA,EAAM,YAAc;UAAAkM,QAAA,EAAU0C;QAAQ,CAAA,EACvC;UAAC5O,IAAA,EAAM,OAAS;UAAAkM,QAAA,EAAU0C;QAAQ,CAAA,EAClC;UAAC5O,IAAA,EAAM,WAAa;UAAAkM,QAAA,EAAUX;QAAG,CAAA,CACnC;MACF;MAEO,OAAA;QACLhV,IAAM,EAAA,SAAA;QACN4U,KAAA;QACAe,QAAU,EAAAX;MAAA,CACZ;IAAA,KACG,GAAK;MAAA;QACFA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;QAErB,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;UACb,OAAA;YACLhV,IAAM,EAAA,SAAA;YACN4U,OAAO,CAAC;cAACnL,MAAM,eAAiB;cAAAkM,QAAA,EAAUwB;aAAS,CAAA;YACnDxB,UAAUX,GAAM,GAAA;UAAA,CAClB;QACF;QAEA,IAAIyD,QAAW,GAAAzD,GAAA;QACf,IAAI1U,MAAS,GAAA0W,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;QAClC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;QAE9B0U,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAW,MAAA,CAAOqV,QAAQ,CAAA;QAEjC,IAAIhW,IAAIqV,GAAS,CAAA,KAAA,GAAA,IAAOrV,GAAI,CAAAqV,GAAA,GAAM,OAAO,GAAK,EAAA;UAC5C,IAAIhV,IAAO,GAAA,WAAA;UACP,IAAAL,GAAA,CAAIqV,GAAM,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;YACjBhV,IAAA,GAAA,WAAA;YACAgV,GAAA,IAAA,CAAA;UAAA,CACF,MAAA;YACEA,GAAA,IAAA,CAAA;UACT;UAEMA,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;UACrB,IAAIoC,GAAM,GAAAJ,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;UAC/B,IAAIoC,IAAIpX,IAAS,KAAA,OAAA,EAAgB,OAAAoX,GAAA;UAC3BpC,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAyX,GAAA,CAAIzB,QAAQ,CAAA;UAC9B,IAAIhW,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK,OAAO;YAAChV,IAAA,EAAM,OAAS;YAAA2V,QAAA,EAAUX;UAAG,CAAA;UAEnD,OAAA;YACLhV,IAAM,EAAA,SAAA;YACN4U,KAAO,EAAA,CACL;cAACnL,IAAA,EAAM,OAAS;cAAAkM,QAAA,EAAUwB;YAAQ,CAAA,EAClC;cAAC1N,IAAA,EAAMzJ,IAAM;cAAA2V,QAAA,EAAU8C;YAAQ,CAAA,CAC/B,CAAA9Q,MAAA,CAAOrH,MAAO,CAAAsU,KAAA,EAAOwC,IAAIxC,KAAK,CAAA;YAChCe,UAAUX,GAAM,GAAA;UAAA,CAClB;QACF;QAEA,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK,OAAO;UAAChV,IAAA,EAAM,OAAS;UAAA2V,QAAA,EAAUX;QAAG,CAAA;QAEnD,OAAA;UACLhV,IAAM,EAAA,SAAA;UACN4U,KAAA,EAAO,CAAC;YAACnL,IAAM,EAAA,gBAAA;YAAkBkM,QAAU,EAAAwB;UAAA,CAAS,CAAA,CAAExP,MAAO,CAAArH,MAAA,CAAOsU,KAAK,CAAA;UACzEe,UAAUX,GAAM,GAAA;QAAA,CAClB;MACF;IAAA,KACK,GAAK;MAAA;QACFA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;QACrB,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;UAChB,IAAA1U,MAAA,GAAS+W,WAAY,CAAA1X,GAAA,EAAKqV,GAAG,CAAA;UACjC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;UACpCA,MAAA,CAAOsU,MAAMsD,OAAQ,CAAA;YAACzO,MAAM,YAAc;YAAAkM,QAAA,EAAUwB;WAAS,CAAA;UACtD,OAAA7W,MAAA;QACT;QACA;MACF;IAAA,KACK,GAAK;MAAA;QACJ,IAAAA,MAAA,GAAS+W,WAAY,CAAA1X,GAAA,EAAKqV,GAAG,CAAA;QACjC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;QACpCA,MAAA,CAAOsU,MAAMsD,OAAQ,CAAA;UAACzO,MAAM,YAAc;UAAAkM,QAAA,EAAUwB;SAAS,CAAA;QACtD,OAAA7W,MAAA;MACT;EAAA;EAGF,OAAO;IAACN,IAAA,EAAM,OAAS;IAAA2V,QAAA,EAAUX;EAAG,CAAA;AACtC;AAEA,SAAS4C,aAAA,CAAcjY,GAAK,EAAAwX,QAAA,EAAUnC,GAAK,EAAA;EACzC,IAAIJ,QAAQ,EAAC;EAEbA,KAAA,CAAMxV,KAAK;IAACqK,IAAA,EAAM,WAAa;IAAAkM,QAAA,EAAUwB;GAAS,CAAA;EAElD,IAAIxX,IAAIqV,GAAS,CAAA,KAAA,GAAA,IAAOrV,GAAI,CAAAqV,GAAA,GAAM,OAAO,GAAK,EAAA;IAC5CJ,KAAA,CAAMxV,KAAK;MAACqK,IAAA,EAAM,WAAa;MAAAkM,QAAA,EAAUwB;KAAS,CAAA;IAClDvC,KAAA,CAAMxV,IAAK,CAAA;MAACqK,IAAM,EAAA,OAAA;MAASkM,QAAU,EAAAwB;KAAW,EAAA;MAAC1N,IAAM,EAAA,WAAA;MAAakM,QAAU,EAAAX;IAAI,CAAA,CAAA;IAC5EA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;IACzB,IAAI2D,OAAU,GAAAnB,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKe,KAAK,CAAA;IACxC,IAAI,CAAC4C,OAAA,EAAS,OAAO;MAAC3Y,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;IAClDJ,KAAA,CAAMxV,IAAK,CAAA;MAACqK,IAAM,EAAA,OAAA;MAASkM,QAAU,EAAAX;IAAA,CAAM,EAAA;MAACvL,IAAM,EAAA,WAAA;MAAakM,QAAU,EAAAX,GAAA,GAAM2D;IAAQ,CAAA,CAAA;IACjF3D,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM2D,OAAO,CAAA;IAC/B,IAAIhZ,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK,OAAO;MAAChV,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;IAC1DA,GAAA,EAAA;IAEMA,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;EAAA,CAChB,MAAA;IACLJ,KAAA,CAAMxV,IAAK,CAAA;MAACqK,IAAM,EAAA,OAAA;MAASkM,QAAU,EAAAwB;KAAW,EAAA;MAAC1N,IAAM,EAAA,WAAA;MAAakM,QAAU,EAAAX;IAAI,CAAA,CAAA;IAC5EA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;EAC3B;EAEA,IAAI4D,OAAU,GAAA5D,GAAA;EAEV,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;IACpB,OAAO,IAAM,EAAA;MACX,IAAI1U,MAAS,GAAA0W,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;MAClC,IAAI1U,OAAON,IAAS,KAAA,OAAA,EAAgB,OAAAM,MAAA;MAC5BsU,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAArH,MAAA,CAAOsU,KAAK,CAAA;MACjCgE,OAAA,GAAUtY,MAAO,CAAAqV,QAAA;MACXX,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAW,MAAA,CAAOqV,QAAQ,CAAA;MACjC,IAAIhW,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;MAChBA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;MAEzB,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;IACxB;EACF;EAEI,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;IACpB,OAAO;MAAChV,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;EACtC;EAGAJ,KAAA,CAAMxV,KAAK;IAACqK,IAAA,EAAM,eAAiB;IAAAkM,QAAA,EAAUiD;GAAQ,CAAA;EAE9C,OAAA;IACL5Y,IAAM,EAAA,SAAA;IACN4U,KAAA;IACAe,UAAUX,GAAM,GAAA;EAAA,CAClB;AACF;AAEA,SAASqC,WAAA,CAAY1X,KAAKqV,GAAK,EAAA;EAC7B,IAAIJ,QAAQ,CAAC;IAACnL,MAAM,QAAU;IAAAkM,QAAA,EAAUX;GAAI,CAAA;EACtCA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;EAEZ,OAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;IAC7B,IAAI6D,OAAU,GAAA7D,GAAA;IAEd,IAAIrV,IAAIuG,KAAM,CAAA8O,GAAA,EAAKA,GAAM,GAAA,CAAC,MAAM,KAAO,EAAA;MAC/BA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;MACzB,IAAIrV,GAAI,CAAAqV,GAAA,CAAA,KAAS,GAAO,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;QACxC,IAAIjK,IAAO,GAAAiM,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;QAChC,IAAIjK,KAAK/K,IAAS,KAAA,OAAA,EAAgB,OAAA+K,IAAA;QAClC6J,KAAA,CAAMxV,KAAK;UAACqK,IAAA,EAAM,cAAgB;UAAAkM,QAAA,EAAUkD;SAAQ,CAAA;QAC5CjE,KAAA,GAAAA,KAAA,CAAMjN,MAAO,CAAAoD,IAAA,CAAK6J,KAAK,CAAA;QAC/BI,GAAA,GAAMjK,IAAK,CAAA4K,QAAA;MAAA,CACN,MAAA;QACLf,KAAA,CAAMxV,KAAK;UAACqK,IAAA,EAAM,mBAAqB;UAAAkM,QAAA,EAAUkD;SAAQ,CAAA;MAC3D;IAAA,CACK,MAAA;MACL,IAAI9N,IAAO,GAAAiM,SAAA,CAAUrX,GAAK,EAAAqV,GAAA,EAAK,CAAC,CAAA;MAChC,IAAIjK,KAAK/K,IAAS,KAAA,OAAA,EAAgB,OAAA+K,IAAA;MAClC,IAAIqN,OAAU,GAAArB,MAAA,CAAOpX,GAAK,EAAAoL,IAAA,CAAK4K,QAAQ,CAAA;MACvC,IAAI5K,KAAK6J,KAAM,CAAA,CAAA,CAAA,CAAGnL,SAAS,KAAS,IAAA9J,GAAA,CAAIyY,aAAa,GAAK,EAAA;QACpD,IAAA7X,KAAA,GAAQyW,UAAUrX,GAAK,EAAAoX,MAAA,CAAOpX,KAAKyY,OAAU,GAAA,CAAC,GAAG,CAAC,CAAA;QACtD,IAAI7X,MAAMP,IAAS,KAAA,OAAA,EAAgB,OAAAO,KAAA;QACnCqU,KAAA,CAAMxV,KAAK;UAACqK,IAAA,EAAM,aAAe;UAAAkM,QAAA,EAAUkD;SAAQ,CAAA;QACnDjE,KAAA,GAAQA,KAAM,CAAAjN,MAAA,CAAOoD,IAAK,CAAA6J,KAAA,EAAOrU,MAAMqU,KAAK,CAAA;QAC5CI,GAAA,GAAMzU,KAAM,CAAAoV,QAAA;MAAA,CACP,MAAA;QACGf,KAAA,GAAAA,KAAA,CAAMjN,OAAO;UAAC8B,IAAA,EAAM;UAAekM,QAAU,EAAAX;QAAM,CAAA,EAAAjK,IAAA,CAAK6J,KAAK,CAAA;QACrEI,GAAA,GAAMjK,IAAK,CAAA4K,QAAA;MACb;IACF;IACMX,GAAA,GAAA+B,MAAA,CAAOpX,KAAKqV,GAAG,CAAA;IACrB,IAAIrV,IAAIqV,GAAS,CAAA,KAAA,GAAA,EAAK;IAChBA,GAAA,GAAA+B,MAAA,CAAOpX,GAAK,EAAAqV,GAAA,GAAM,CAAC,CAAA;EAC3B;EAEI,IAAArV,GAAA,CAAIqV,SAAS,GAAK,EAAA;IACpB,OAAO;MAAChV,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;EACtC;EAEAA,GAAA,EAAA;EACAJ,KAAA,CAAMxV,KAAK;IAACqK,IAAA,EAAM,YAAc;IAAAkM,QAAA,EAAUX;GAAI,CAAA;EAC9C,OAAO;IAAChV,IAAA,EAAM,SAAW;IAAA4U,KAAA;IAAOe,UAAUX;EAAG,CAAA;AAC/C;AAEA,SAASsC,WAAA,CAAY3X,KAAKqV,GAAK,EAAA;EAC7B,IAAIjP,QAAQpG,GAAI,CAAAqV,GAAA,CAAA;EAChBA,GAAA,GAAMA,GAAM,GAAA,CAAA;EACZ,MAAMJ,QAAQ,CAAC;IAACnL,MAAM,KAAO;IAAAkM,QAAA,EAAUX;GAAI,CAAA;EAC3CrV,GAAA,EAAK,QAASqV,GAAO,EAAA,EAAA;IACnB,IAAIA,MAAMrV,GAAI,CAAAgB,MAAA,EAAQ,OAAO;MAACX,IAAA,EAAM,OAAS;MAAA2V,QAAA,EAAUX;IAAG,CAAA;IAE1D,QAAQrV,GAAI,CAAAqV,GAAA,CAAA;MAAA,KACLjP,KAAO;QAAA;UACV6O,KAAA,CAAMxV,KAAK;YAACqK,IAAA,EAAM,SAAW;YAAAkM,QAAA,EAAUX;WAAI,CAAA;UAC3CA,GAAA,EAAA;UACM,MAAArV,GAAA;QACR;MAAA,KACK,IAAM;QAAA;UACTiV,KAAA,CAAMxV,KAAK;YAACqK,IAAA,EAAM,WAAa;YAAAkM,QAAA,EAAUX;WAAI,CAAA;UACzC,IAAArV,GAAA,CAAIqV,GAAM,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;YACpB,IAAArV,GAAA,CAAIqV,GAAM,GAAA,CAAA,CAAA,KAAO,GAAK,EAAA;cACxBJ,KAAA,CAAMxV,KAAK;gBAACqK,IAAA,EAAM;gBAAekM,QAAU,EAAAX,GAAA,GAAM;eAAE,CAAA;cACnDA,GAAA,GAAMrV,GAAI,CAAAmZ,OAAA,CAAQ,GAAK,EAAA9D,GAAA,GAAM,CAAC,CAAA;cAC9BJ,KAAA,CAAMxV,KAAK;gBAACqK,IAAA,EAAM,iBAAmB;gBAAAkM,QAAA,EAAUX;eAAI,CAAA;YAAA,CAC9C,MAAA;cACLJ,KAAA,CAAMxV,KAAK;gBAACqK,IAAA,EAAM;gBAAekM,QAAU,EAAAX,GAAA,GAAM;eAAE,CAAA;cACnDJ,KAAA,CAAMxV,KAAK;gBAACqK,IAAA,EAAM;gBAAmBkM,QAAU,EAAAX,GAAA,GAAM;eAAE,CAAA;cAChDA,GAAA,IAAA,CAAA;YACT;UAAA,CACK,MAAA;YACLJ,KAAA,CAAMxV,KAAK;cAACqK,IAAA,EAAM;cAAiBkM,QAAU,EAAAX,GAAA,GAAM;aAAE,CAAA;YAC9CA,GAAA,IAAA,CAAA;UACT;UACAJ,KAAA,CAAMxV,KAAK;YAACqK,IAAA,EAAM;YAAakM,QAAU,EAAAX,GAAA,GAAM;WAAE,CAAA;QACnD;IAAA;EAEJ;EAEA,OAAO;IAAChV,IAAA,EAAM,SAAW;IAAA4U,KAAA;IAAOe,UAAUX;EAAG,CAAA;AAC/C;AAEA,SAAS+B,MAAA,CAAOpX,KAAKqV,GAAK,EAAA;EACxB,OAAOA,GAAM,GAAAwC,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAKa,EAAE,CAAA;AACtC;AAKA,SAAS2B,UAAA,CAAW7X,GAAK,EAAAqV,GAAA,EAAK/V,EAAI,EAAA;EAChC,IAAI8Z,IAAI9Z,EAAG,CAAA+Z,IAAA,CAAKrZ,GAAI,CAAAuG,KAAA,CAAM8O,GAAG,CAAC,CAAA;EACvB,OAAA+D,CAAA,GAAIA,CAAE,CAAA,CAAA,CAAA,CAAGpY,MAAS,GAAA,CAAA;AAC3B;AAKA,SAAS4X,aAAA,CAAc5Y,GAAK,EAAAqV,GAAA,EAAK/V,EAAI,EAAA;EACnC,IAAI8Z,IAAI9Z,EAAG,CAAA+Z,IAAA,CAAKrZ,GAAI,CAAAuG,KAAA,CAAM8O,GAAG,CAAC,CAAA;EACvB,OAAA+D,CAAA,GAAIA,EAAE,CAAK,CAAA,GAAA,IAAA;AACpB;AC3xBA,SAASzZ,IAAA,CAAKuF,GAAcC,CAAyB,EAAA;EACnD,OAAQ4F,IAAA,IAAmB5F,CAAE,CAAAD,CAAA,CAAE6F,IAAI,CAAC,CAAA;AACtC;AAKA,SAAS7E,IAAIgI,KAA6B,EAAA;EACxC,OAAQnD,IAAA,KAAoB;IAAC1K,IAAA,EAAM,KAAO;IAAA0K,IAAA;IAAMK,IAAM,EAAA8C,KAAA,CAAM;MAAC7N,IAAA,EAAM;IAAO,CAAA;EAAC,CAAA,CAAA;AAC7E;AAEA,SAASiZ,QAAQpL,KAA6B,EAAA;EAC5C,OAAQnD,IAAA,KAAoB;IAAC1K,IAAA,EAAM,SAAW;IAAA0K,IAAA;IAAMK,IAAM,EAAA8C,KAAA,CAAM;MAAC7N,IAAA,EAAM;IAAO,CAAA;EAAC,CAAA,CAAA;AACjF;AAOgB,SAAAkZ,aAAA,CAAcC,OAAkBhS,KAAgD,EAAA;EAC9F,IAAI,CAACA,KAAO,EAAA;IACH,OAAA;MACLnH,IAAM,EAAA,KAAA;MACNmZ;IAAA,CACF;EACF;EAEA,QAAQhS,KAAM,CAAAnH,IAAA;IACP,KAAA,KAAA;MACI,OAAA;QACLA,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAK6Z,KAAO,EAAAhS,KAAA,CAAMgS,KAAK;MAAA,CAChC;IAEG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAK6Z,KAAO,EAAAhS,KAAA,CAAMgS,KAAK;MAAA,CAChC;IAEG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,OAAO7Z,IAAK,CAAA6Z,KAAA,EAAOtT,GAAI,CAAAsB,KAAA,CAAMgS,KAAK,CAAC;MAAA,CACrC;IAEG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,OAAO7Z,IAAK,CAAA6Z,KAAA,EAAOF,OAAQ,CAAA9R,KAAA,CAAMgS,KAAK,CAAC;MAAA,CACzC;IAAA;MAGA,MAAM,IAAIpW,KAAA,yBAAuBoE,KAAA,CAAMnH,IAAM,EAAA;EAAA;AAEnD;AAEgB,SAAAoZ,aAAA,CAAcrG,QAAmB5L,KAAgD,EAAA;EAC/F,IAAI,CAACA,KAAO,EAAA;IACH,OAAA;MACLnH,IAAM,EAAA,KAAA;MACNmZ,KAAO,EAAApG;IAAA,CACT;EACF;EAEA,QAAQ5L,KAAM,CAAAnH,IAAA;IACP,KAAA,KAAA;IACA,KAAA,KAAA;MACI,OAAA;QACLA,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IAEG,KAAA,KAAA;IACA,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IAAA;MAGA,MAAM,IAAIpW,KAAA,yBAAuBoE,KAAA,CAAMnH,IAAM,EAAA;EAAA;AAEnD;AAEgB,SAAAqZ,eAAA,CAAgBtG,QAAmB5L,KAAgD,EAAA;EACjG,IAAI,CAACA,KAAO,EAAA;IACH,OAAA;MACLnH,IAAM,EAAA,KAAA;MACNmZ,KAAO,EAAApG;IAAA,CACT;EACF;EAEA,QAAQ5L,KAAM,CAAAnH,IAAA;IACP,KAAA,KAAA;IACA,KAAA,KAAA;MACI,OAAA;QACLA,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IAEG,KAAA,KAAA;IACA,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IAAA;MAGA,MAAM,IAAIpW,KAAA,yBAAuBoE,KAAA,CAAMnH,IAAM,EAAA;EAAA;AAEnD;AAEgB,SAAAsZ,kBAAA,CACdvG,QACA5L,KACiB,EAAA;EACjB,IAAI,CAACA,KAAO,EAAA;IACH,OAAA;MACLnH,IAAM,EAAA,KAAA;MACNmZ,KAAO,EAAApG;IAAA,CACT;EACF;EAEA,QAAQ5L,KAAM,CAAAnH,IAAA;IACP,KAAA,KAAA;MACI,OAAA;QACLA,IAAM,EAAA,KAAA;QACNmZ,OAAO7Z,IAAK,CAAAuG,GAAA,CAAIkN,MAAM,CAAA,EAAG5L,MAAMgS,KAAK;MAAA,CACtC;IACG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,OAAO7Z,IAAK,CAAAuG,GAAA,CAAIkN,MAAM,CAAA,EAAG5L,MAAMgS,KAAK;MAAA,CACtC;IACG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IACG,KAAA,KAAA;MACI,OAAA;QACLnZ,IAAM,EAAA,KAAA;QACNmZ,KAAO,EAAA7Z,IAAA,CAAKyT,MAAQ,EAAA5L,KAAA,CAAMgS,KAAK;MAAA,CACjC;IAAA;MAEA,MAAM,IAAIpW,KAAA,yBAAuBoE,KAAA,CAAMnH,IAAM,EAAA;EAAA;AAEnD;ACpIA,MAAMuZ,eAAsD,GAAA;EAC1D,GAAK,EAAA,GAAA;EACL,GAAK,EAAA,GAAA;EACL,IAAM,EAAA,IAAA;EACN,GAAK,EAAA,GAAA;EACLzU,CAAG,EAAA,IAAA;EACH0U,CAAG,EAAA,IAAA;EACH3P,CAAG,EAAA,IAAA;EACH4P,CAAG,EAAA,IAAA;EACHC,CAAG,EAAA;AACL,CAAA;AAEA,SAASC,UAAUha,GAAqB,EAAA;EAChC,MAAAia,QAAA,GAAWC,QAAS,CAAAla,GAAA,EAAK,EAAE,CAAA;EAC1B,OAAAma,MAAA,CAAOC,aAAaH,QAAQ,CAAA;AACrC;AAEA,MAAMI,uBAAuBjX,KAAM,CAAA;EAAnCvD,WAAA,GAAA;IAAA,KAAA,CAAA,GAAAya,SAAA,CAAA;IACE,IAAA,CAAOxQ,IAAO,GAAA,gBAAA;EAAA;AAChB;AAEA,MAAMyQ,YAAsC,GAAA;EAC1CC,MAAMC,CAAG,EAAA;IACD,MAAAvM,KAAA,GAAQuM,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,OAAA;MACN0K,IAAM,EAAAmD;IAAA,CACR;EACF,CAAA;EAEAwM,UAAa,GAAA;IACJ,OAAA;MAACra,MAAM;KAAY;EAC5B,CAAA;EAEAsa,IAAO,GAAA;IACE,OAAA;MAACta,MAAM;KAAM;EACtB,CAAA;EAEAwI,MAAS,GAAA;IACA,OAAA;MACLxI,IAAM,EAAA,QAAA;MACN6J,CAAG,EAAA;IAAA,CACL;EACF,CAAA;EAEA0Q,UAAUH,CAAG,EAAA;IACL,MAAA3V,IAAA,GAAO2V,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC5B,OAAA;MACLla,IAAM,EAAA,QAAA;MACN6J,CAAA,EAAGpF,KAAKoF,CAAI,GAAA;IAAA,CACd;EACF,CAAA;EAEA2Q,SAASJ,CAAG,EAAA;IACJ,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IACnC,MAAMO,gBAA2E,EAAC;IAClF,OAAOL,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,eAAiB,EAAA;MAC3CgR,aAAA,CAAcrb,IAAK,CAAAgb,CAAA,CAAEjF,OAAQ,CAAAuF,gBAAgB,CAAC,CAAA;IAChD;IACAN,CAAA,CAAElF,KAAM,EAAA;IACR,IAAIyF,SAAoC,GAAA,IAAA;IACxC,KAAA,IAASja,IAAI+Z,aAAc,CAAA9Z,MAAA,GAAS,CAAG,EAAAD,CAAA,IAAK,GAAGA,CAAK,EAAA,EAAA;MACtCia,SAAA,GAAAF,aAAA,CAAc/Z,GAAGia,SAAS,CAAA;IACxC;IACI,IAAAjQ,IAAA,CAAK1K,SAAS,YAAgB,IAAA0K,IAAA,CAAK1K,SAAS,OAAW,IAAA0K,IAAA,CAAK1K,SAAS,cAAgB,EAAA;MACvF2a,SAAA,GAAYzB,aAAc,CAACxU,GAAQ,IAAAA,GAAA,EAAKiW,SAAS,CAAA;IACnD;IACA,IAAIA,SAAc,KAAA,IAAA,EAAY,MAAA,IAAI5X,MAAM,iCAAiC,CAAA;IAClE,OAAA4X,SAAA,CAAUxB,MAAMzO,IAAI,CAAA;EAC7B,CAAA;EAEAkQ,UAAUR,CAAG,EAAA;IACL,MAAA3Q,IAAA,GAAO2Q,EAAE7E,aAAc,EAAA;IAE7B,IAAI9L,SAAS,MAAQ,EAAA;MACnB,OAAO;QAACzJ,IAAA,EAAM,OAAS;QAAAO,KAAA,EAAO;MAAI,CAAA;IACpC;IACA,IAAIkJ,SAAS,MAAQ,EAAA;MACnB,OAAO;QAACzJ,IAAA,EAAM,OAAS;QAAAO,KAAA,EAAO;MAAI,CAAA;IACpC;IACA,IAAIkJ,SAAS,OAAS,EAAA;MACpB,OAAO;QAACzJ,IAAA,EAAM,OAAS;QAAAO,KAAA,EAAO;MAAK,CAAA;IACrC;IAEO,OAAA;MACLP,IAAM,EAAA,iBAAA;MACNyJ;IAAA,CACF;EACF,CAAA;EAEAoR,IAAIT,CAAG,EAAA;IACC,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE5B,OAAA;MACLla,IAAM,EAAA,KAAA;MACN0K;IAAA,CACF;EACF,CAAA;EAEAsK,IAAIoF,CAAG,EAAA;IACC,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE5B,OAAA;MACLla,IAAM,EAAA,KAAA;MACN0K;IAAA,CACF;EACF,CAAA;EAEAjH,IAAI2W,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,GAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEA2T,IAAIV,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,GAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEA4T,IAAIX,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,GAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEA6T,IAAIZ,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,GAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEA8T,IAAIb,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,GAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEAe,IAAIkS,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAI,EAAA,IAAA;MACJ9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEA+T,KAAKd,CAAG,EAAA;IACA,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAAlQ,EAAA,GAAKoQ,EAAE7E,aAAc,EAAA;IACrB,MAAApO,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,QAAA;MACNgK,EAAA;MACA9C,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEAgU,SAASf,CAAG,EAAA;IACJ,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IACnC,MAAMvP,WAAc,GAAAyP,CAAA,CAAEnF,OAAQ,EAAA,CAAExL,IAAS,KAAA,WAAA;IACzC2Q,CAAA,CAAElF,KAAM,EAAA;IACF,MAAAhO,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,SAAA;MACN0K,IAAA;MACAxD,IAAA;MACAC,KAAA;MACAwD;IAAA,CACF;EACF,CAAA;EAEAhL,IAAIya,CAAG,EAAA;IACL,IAAI7Z,KAAQ,GAAA,EAAA;IAEZwX,IAAA,EAAa,OAAAqC,CAAA,CAAErF,SAAW,EAAA;MAClB,MAAAM,IAAA,GAAO+E,EAAEnF,OAAQ,EAAA;MACvB,QAAQI,IAAK,CAAA5L,IAAA;QACN,KAAA,SAAA;UACHlJ,KAAA,IAAS6Z,EAAE5E,gBAAiB,EAAA;UAEtB,MAAAuC,IAAA;QACH,KAAA,WAAA;UACHxX,KAAA,IAAS6Z,EAAE5E,gBAAiB,EAAA;UAC5B;QACG,KAAA,WAAA;UACH4E,CAAA,CAAElF,KAAM,EAAA;UACR;QAAA,KACG,eAAiB;UAAA;YACd,MAAAkG,IAAA,GAAOhB,CAAE,CAAAlU,KAAA,CAAM,CAAC,CAAA;YACtBkU,CAAA,CAAElF,KAAM,EAAA;YACR3U,KAAA,IAASgZ,eAAgB,CAAA6B,IAAA,CAAA;YACzB;UACF;QACK,KAAA,aAAA;UACHhB,CAAA,CAAElF,KAAM,EAAA;UACC3U,KAAA,IAAAoZ,SAAA,CAAUS,CAAE,CAAA5E,gBAAA,EAAkB,CAAA;UACvC;QAAA;UAEA,MAAM,IAAIzS,KAAA,4BAA0BsS,IAAA,CAAK5L,IAAM,EAAA;MAAA;IAErD;IACO,OAAA;MAACzJ,IAAM,EAAA,OAAA;MAASO;KAAK;EAC9B,CAAA;EAEA8a,QAAQjB,CAAG,EAAA;IACH,MAAAkB,QAAA,GAAWlB,EAAE5E,gBAAiB,EAAA;IAC7B,OAAA;MACLxV,IAAM,EAAA,OAAA;MACNO,KAAA,EAAOyD,OAAOsX,QAAQ;IAAA,CACxB;EACF,CAAA;EAEAC,MAAMnB,CAAG,EAAA;IACD,MAAAkB,QAAA,GAAWlB,EAAE5E,gBAAiB,EAAA;IAC7B,OAAA;MACLxV,IAAM,EAAA,OAAA;MACNO,KAAA,EAAOyD,OAAOsX,QAAQ;IAAA,CACxB;EACF,CAAA;EAEAE,IAAIpB,CAAG,EAAA;IACC,MAAAkB,QAAA,GAAWlB,EAAE5E,gBAAiB,EAAA;IAC7B,OAAA;MACLxV,IAAM,EAAA,OAAA;MACNO,KAAA,EAAOyD,OAAOsX,QAAQ;IAAA,CACxB;EACF,CAAA;EAEAG,OAAOrB,CAAG,EAAA;IACR,MAAM3N,aAAoC,EAAC;IAC3C,OAAO2N,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,YAAc,EAAA;MACxCgD,UAAA,CAAWrN,IAAK,CAAAgb,CAAA,CAAEjF,OAAQ,CAAAuG,cAAc,CAAC,CAAA;IAC3C;IACAtB,CAAA,CAAElF,KAAM,EAAA;IAED,OAAA;MACLlV,IAAM,EAAA,QAAA;MACNyM;IAAA,CACF;EACF,CAAA;EAEAX,MAAMsO,CAAG,EAAA;IACP,MAAMtN,WAA+B,EAAC;IACtC,OAAOsN,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,WAAa,EAAA;MACvC,IAAIsD,OAAU,GAAA,KAAA;MACd,IAAIqN,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,aAAe,EAAA;QAC5BsD,OAAA,GAAA,IAAA;QACVqN,CAAA,CAAElF,KAAM,EAAA;MACV;MACM,MAAA3U,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;MACpCpN,QAAA,CAAS1N,IAAK,CAAA;QACZY,IAAM,EAAA,cAAA;QACNO,KAAA;QACAwM;MAAA,CACD,CAAA;IACH;IACAqN,CAAA,CAAElF,KAAM,EAAA;IACD,OAAA;MACLlV,IAAM,EAAA,OAAA;MACN8M;IAAA,CACF;EACF,CAAA;EAEAqG,MAAMiH,CAAG,EAAA;IACP,MAAMuB,UAAsB,EAAC;IAC7B,OAAOvB,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,WAAa,EAAA;MACvCkS,OAAA,CAAQvc,IAAK,CAAAgb,CAAA,CAAEjF,OAAQ,CAAA+E,YAAY,CAAC,CAAA;IACtC;IACAE,CAAA,CAAElF,KAAM,EAAA;IACD,OAAA;MACLlV,IAAM,EAAA,OAAA;MACN2b;IAAA,CACF;EACF,CAAA;EAEAC,UAAUxB,CAAG,EAAA;IACX,IAAIyB,SAAY,GAAA,QAAA;IAChB,IAAIzB,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,WAAa,EAAA;MACpC2Q,CAAA,CAAElF,KAAM,EAAA;MACR2G,SAAA,GAAYzB,EAAE7E,aAAc,EAAA;IAC9B;IAEM,MAAA9L,IAAA,GAAO2Q,EAAE7E,aAAc,EAAA;IACzB,IAAAsG,SAAA,KAAc,QAAY,IAAApS,IAAA,KAAS,QAAU,EAAA;MAC/C,MAAMnJ,MAAqB,GAAA;QACzBN,IAAM,EAAA,QAAA;QACNoK,cAAc;MAAC,CACjB;MAEA,OAAOgQ,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,eAAiB,EAAA;QAC3C,IAAI2Q,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,MAAQ,EAAA;UAC/B,IAAInJ,MAAO,CAAA+J,QAAA,EAAgB,MAAA,IAAI2P,iDAAgD;UAC/EI,CAAA,CAAElF,KAAM,EAAA;UACF,MAAA1K,SAAA,GAAY4P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;UAClC,MAAA3Z,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;UACpC5Z,MAAA,CAAO8J,aAAahL,IAAK,CAAA;YACvBY,IAAM,EAAA,mBAAA;YACNwK,SAAA;YACAjK;UAAA,CACD,CAAA;QAAA,CACI,MAAA;UACL,IAAID,MAAO,CAAA+J,QAAA,EAAgB,MAAA,IAAI2P,iDAAgD;UACzE,MAAAzZ,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;UACpC5Z,MAAA,CAAO+J,QAAW,GAAA9J,KAAA;QACpB;MACF;MACA6Z,CAAA,CAAElF,KAAM,EAAA;MACD,OAAA5U,MAAA;IACT;IAEA,MAAMgL,OAAmB,EAAC;IAE1B,OAAO8O,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,eAAiB,EAAA;MAC3C,IAAIqS,wBAAyB,CAAAD,SAAA,EAAWpS,IAAM,EAAA6B,IAAA,CAAK3K,MAAM,CAAG,EAAA;QAG1DyZ,CAAA,CAAEjF,QAAQ4G,gBAAgB,CAAA;QAC1BzQ,IAAA,CAAKlM,IAAK,CAAA;UAACY,IAAM,EAAA;QAAW,CAAA,CAAA;MAAA,CACvB,MAAA;QACLsL,IAAA,CAAKlM,IAAK,CAAAgb,CAAA,CAAEjF,OAAQ,CAAA+E,YAAY,CAAC,CAAA;MACnC;IACF;IAEAE,CAAA,CAAElF,KAAM,EAAA;IAER,IAAI2G,SAAc,KAAA,QAAA,KAAapS,IAAS,KAAA,QAAA,IAAYA,SAAS,OAAU,CAAA,EAAA;MACjE,IAAA2Q,CAAA,CAAEvF,YAAa,CAAAZ,IAAA,KAAS,OAAS,EAAA;QAC5B,OAAA;UACLjU,IAAM,EAAA,SAAA;UACN2J,GAAK,EAAAF;QAAA,CACP;MACF;IACF;IAEA,IAAIoS,SAAc,KAAA,QAAA,IAAYpS,IAAS,KAAA,OAAA,IAAW,CAAC2Q,CAAE,CAAAtF,UAAA,EAC7C,MAAA,IAAIkF,eAAe,kBAAkB,CAAA;IAE7C,MAAMgC,QAAQvH,UAAW,CAAAoH,SAAA,CAAA;IACzB,IAAI,CAACG,KAAO,EAAA;MACJ,MAAA,IAAIhC,cAAe,gCAAwB6B,SAAW,EAAA;IAC9D;IAEA,MAAM7S,OAAOgT,KAAM,CAAAvS,IAAA,CAAA;IACnB,IAAI,CAACT,IAAM,EAAA;MACH,MAAA,IAAIgR,cAAe,+BAAuBvQ,IAAM,EAAA;IACxD;IACI,IAAAT,IAAA,CAAK0H,UAAU,KAAW,CAAA,EAAA;MAC5BuL,aAAA,CAAcxS,IAAM,EAAAT,IAAA,CAAK0H,KAAO,EAAApF,IAAA,CAAK3K,MAAM,CAAA;IAC7C;IAEA,IAAIqI,KAAKiL,IAAS,KAAA,KAAA,CAAA,IAAajL,KAAKiL,IAAS,KAAAmG,CAAA,CAAEvF,aAAaZ,IAAM,EAAA;MAC1D,MAAA,IAAI+F,cAAe,+BAAuBvQ,IAAM,EAAA;IACxD;IAEO,OAAA;MACLzJ,IAAM,EAAA,UAAA;MACNgJ,IAAA;MACAS,IAAA;MACA6B;IAAA,CACF;EACF,CAAA;EAEA4Q,SAAS9B,CAAG,EAAA;IACJ,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IACnCE,CAAA,CAAElF,KAAM,EAAA;IAER,IAAI2G,SAAY,GAAA,QAAA;IAChB,IAAIzB,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,WAAa,EAAA;MACpC2Q,CAAA,CAAElF,KAAM,EAAA;MACR2G,SAAA,GAAYzB,EAAE7E,aAAc,EAAA;IAC9B;IACA,IAAIsG,cAAc,QAAU,EAAA;MACpB,MAAA,IAAI7B,cAAe,gCAAwB6B,SAAW,EAAA;IAC9D;IAEM,MAAApS,IAAA,GAAO2Q,EAAE7E,aAAc,EAAA;IAC7B,MAAMjK,OAAmB,EAAC;IAE1B,MAAM6Q,gBAAgB/B,CAAE,CAAAtF,UAAA;IACxB,IAAIrL,SAAS,OAAS,EAAA;MAEpB2Q,CAAA,CAAEtF,UAAa,GAAA,IAAA;IACjB;IAES,SAAA;MACD,MAAAsH,QAAA,GAAWhC,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA;MAC7B,IAAI2S,aAAa,eAAiB,EAAA;QAChC;MACF;MAEA,IAAI3S,SAAS,OAAS,EAAA;QACpB,IAAI2S,aAAa,KAAO,EAAA;UACtBhC,CAAA,CAAElF,KAAM,EAAA;UACH5J,IAAA,CAAAlM,IAAA,CAAK;YAACY,IAAM,EAAA,KAAA;YAAO0K,MAAM0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY;UAAA,CAAE,CAAA;UACtD;QAAA,CACF,MAAA,IAAWkC,aAAa,MAAQ,EAAA;UAC9BhC,CAAA,CAAElF,KAAM,EAAA;UACH5J,IAAA,CAAAlM,IAAA,CAAK;YAACY,IAAM,EAAA,MAAA;YAAQ0K,MAAM0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY;UAAA,CAAE,CAAA;UACvD;QACF;MACF;MAEA5O,IAAA,CAAKlM,IAAK,CAAAgb,CAAA,CAAEjF,OAAQ,CAAA+E,YAAY,CAAC,CAAA;IACnC;IACAE,CAAA,CAAElF,KAAM,EAAA;IAERkF,CAAA,CAAEtF,UAAa,GAAAqH,aAAA;IAEf,MAAMnT,OAAO2J,aAAc,CAAAlJ,IAAA,CAAA;IAC3B,IAAI,CAACT,IAAM,EAAA;MACH,MAAA,IAAIgR,cAAe,oCAA4BvQ,IAAM,EAAA;IAC7D;IACA,IAAIT,KAAK0H,KAAO,EAAA;MACduL,aAAA,CAAcxS,IAAM,EAAAT,IAAA,CAAK0H,KAAO,EAAApF,IAAA,CAAK3K,MAAM,CAAA;IAC7C;IAEO,OAAA;MACLX,IAAM,EAAA,cAAA;MACNgJ,IAAA;MACA0B,IAAA;MACAjB,IAAA;MACA6B;IAAA,CACF;EACF,CAAA;EAEA+Q,KAAKjC,CAAG,EAAA;IACA,MAAA,IAAIJ,+BAA8B;EAC1C,CAAA;EAEAsC,IAAIlC,CAAG,EAAA;IACC,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,KAAA;MACNkH,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEAoV,GAAGnC,CAAG,EAAA;IACE,MAAAlT,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,IAAA;MACNkH,IAAA;MACAC;IAAA,CACF;EACF,CAAA;EAEAqV,IAAIpC,CAAG,EAAA;IACC,MAAA1P,IAAA,GAAO0P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC5B,OAAA;MACLla,IAAM,EAAA,KAAA;MACN0K;IAAA,CACF;EACF,CAAA;EAEA+R,IAAIrC,CAAG,EAAA;IACC,MAAA,IAAIJ,eAAe,gBAAgB,CAAA;EAC3C,CAAA;EAEA0C,KAAKtC,CAAG,EAAA;IACA,MAAA,IAAIJ,eAAe,iBAAiB,CAAA;EAC5C,CAAA;EAEA2C,MAAMvC,CAAG,EAAA;IACD,MAAA3Q,IAAA,GAAO2Q,EAAE7E,aAAc,EAAA;IAEzB,IAAA6E,CAAA,CAAEvF,aAAaxM,MAAU,IAAA+R,CAAA,CAAEvF,aAAaxM,MAAO,CAAAoD,cAAA,CAAehC,IAAI,CAAG,EAAA;MAChE,OAAA;QACLzJ,IAAM,EAAA,OAAA;QACNO,KAAA,EAAO6Z,CAAE,CAAAvF,YAAA,CAAaxM,MAAO,CAAAoB,IAAA;MAAA,CAC/B;IACF;IAEO,OAAA;MACLzJ,IAAM,EAAA,WAAA;MACNyJ;IAAA,CACF;EACF;AACF,CAAA;AAEA,MAAMiS,cAAmD,GAAA;EACvDkB,YAAYxC,CAAG,EAAA;IACb,IAAIA,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,MAAQ,EAAA;MAC/B2Q,CAAA,CAAElF,KAAM,EAAA;MACF,MAAA1K,SAAA,GAAY4P,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;MAClC3Z,MAAAA,MAAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;MAE7B,OAAA;QACLla,IAAM,EAAA,wBAAA;QACNwK,SAAA;QACAjK,KAAAA,EAAAA;MAAA,CACF;IACF;IAEM,MAAAA,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE7B,OAAA;MACLla,IAAM,EAAA,sBAAA;MACNyJ,IAAA,EAAMoT,mBAAmBtc,KAAK,CAAA;MAC9BA;IAAA,CACF;EACF,CAAA;EAEAuc,YAAY1C,CAAG,EAAA;IACP,MAAA3Q,IAAA,GAAO2Q,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IACnC,IAAIzQ,KAAKzJ,IAAS,KAAA,OAAA,EAAe,MAAA,IAAI+C,MAAM,qBAAqB,CAAA;IAE1D,MAAAxC,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,OAAA;MACLla,IAAM,EAAA,sBAAA;MACNyJ,MAAMA,IAAK,CAAAlJ,KAAA;MACXA;IAAA,CACF;EACF,CAAA;EAEAwc,aAAa3C,CAAoB,EAAA;IACzB,MAAA7Z,KAAA,GAAQ6Z,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE7B,OAAA;MACLla,IAAM,EAAA,aAAA;MACNO;IAAA,CACF;EACF,CAAA;EAEAyc,iBAAqC,GAAA;IAC5B,OAAA;MACLhd,IAAM,EAAA,aAAA;MACNO,KAAA,EAAO;QAACP,IAAA,EAAM;MAAM;IAAA,CACtB;EACF;AACF,CAAA;AAEA,MAAM0a,gBAAkF,GAAA;EACtFuC,eAAe7C,CAAG,EAAA;IACV,MAAArP,IAAA,GAAOqP,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE7B,MAAA3Z,KAAA,GAAQmO,oBAAoB3D,IAAI,CAAA;IAClC,IAAAxK,KAAA,IAASA,KAAM,CAAAP,IAAA,KAAS,QAAU,EAAA;MACpC,OAAQmH,KAAA,IACNkS,eAAgB,CAAC3O,IAAU,KAAA;QAAC1K,IAAM,EAAA,eAAA;QAAiB0K,IAAM;QAAAiB,KAAA,EAAOpL,KAAM,CAAAJ;MAAA,IAAQgH,KAAK,CAAA;IACvF;IAEI,IAAA5G,KAAA,IAASA,KAAM,CAAAP,IAAA,KAAS,QAAU,EAAA;MACpC,OAAQmH,KAAA,IACNiS,aAAc,CAAC1O,IAAU,KAAA;QAAC1K,IAAM,EAAA,iBAAA;QAAmB0K,IAAM;QAAAjB,IAAA,EAAMlJ,KAAM,CAAAJ;MAAA,IAAQgH,KAAK,CAAA;IACtF;IAEA,OAAQA,KACN,IAAA+R,aAAA,CACGxO,IAAU,KAAA;MACT1K,IAAM,EAAA,QAAA;MACN0K,IAAA;MACAK;IAAA,CACF,CAAA,EACA5D,KAAA,CACF;EACJ,CAAA;EAEAjB,MAAMkU,CAAG,EAAA;IACP,MAAMzP,WAAc,GAAAyP,CAAA,CAAEnF,OAAQ,EAAA,CAAExL,IAAS,KAAA,WAAA;IACzC2Q,CAAA,CAAElF,KAAM,EAAA;IAEF,MAAAhO,IAAA,GAAOkT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAC7B,MAAA/S,KAAA,GAAQiT,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAE9B,MAAAjQ,SAAA,GAAYyE,oBAAoBxH,IAAI,CAAA;IACpC,MAAAgD,UAAA,GAAawE,oBAAoBvH,KAAK,CAAA;IAExC,IAAA,CAAC8C,aAAa,CAACC,UAAA,IAAcD,UAAUjK,IAAS,KAAA,QAAA,IAAYkK,UAAW,CAAAlK,IAAA,KAAS,QAAU,EAAA;MACtF,MAAA,IAAIga,eAAe,mCAAmC,CAAA;IAC9D;IAEA,OAAQ5C,GACN,IAAA8B,aAAA,CACGxO,IAAU,KAAA;MACT1K,IAAM,EAAA,OAAA;MACN0K,IAAA;MACAxD,MAAM+C,SAAU,CAAA9J,IAAA;MAChBgH,OAAO+C,UAAW,CAAA/J,IAAA;MAClBwK;IAAA,CACF,CAAA,EACAyM,GAAA,CACF;EACJ,CAAA;EAEA8F,WAAW9C,CAAG,EAAA;IACN,MAAA5V,GAAA,GAAM4V,CAAE,CAAAjF,OAAA,CAAQ+E,YAAY,CAAA;IAClC,OAAQ/S,KAAA,IACNmS,kBAAmB,CAAC5O,IAAU,KAAA;MAAC1K,IAAM,EAAA,YAAA;MAAc0K,IAAY;MAAAK,IAAA,EAAMvG;KAAG,CAAA,EAAI2C,KAAK,CAAA;EACrF,CAAA;EAEAgW,YAAY/C,CAAG,EAAA;IACP,MAAA3Q,IAAA,GAAO2Q,EAAE7E,aAAc,EAAA;IAEtB,OAACpO,KAAU,IAAAiS,aAAA,CAAe1O,IAAA,KAAU;MAAC1K,IAAA,EAAM,iBAAmB;MAAA0K,IAAA;MAAMjB;KAAI,CAAA,EAAItC,KAAK,CAAA;EAC1F,CAAA;EAEAiW,MAAMhD,CAAG,EAAA;IACP,IAAI1N,IAAsB,GAAA,IAAA;IAE1B,IAAI0N,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,YAAc,EAAA;MACrC2Q,CAAA,CAAElF,KAAM,EAAA;MACRxI,IAAA,GAAO0N,EAAE7E,aAAc,EAAA;IACzB;IAEM,MAAA8H,IAAA,GAAQ3S,IAAA,IACZgC,IAAO,GAAA;MAAC1M,MAAM,iBAAmB;MAAA0K,IAAA;MAAMjB,IAAM,EAAAiD;IAAA,CAAQ,GAAAhC,IAAA;IAEvD,OAAQvD,KACN,IAAAiS,aAAA,CACG1O,QACC2S,IAAK,CAAA;MACHrd,IAAM,EAAA,OAAA;MACN0K;IAAA,CACD,CAAA,EACHvD,KAAA,CACF;EACJ,CAAA;EAEAmW,cAAclD,CAAG,EAAA;IACR,OAACjT,KAAU,IAAA+R,aAAA,CAAexO,IAAA,KAAU;MAAC1K,IAAM,EAAA,aAAA;MAAe0K;IAAI,CAAA,CAAA,EAAIvD,KAAK,CAAA;EAChF;AACF,CAAA;AAEA,MAAM4U,gBAAsC,GAAA;EAC1C5B,MAAMC,CAAG,EAAA;IACPA,CAAA,CAAEjF,QAAQ4G,gBAAgB,CAAA;IACnB,OAAA,IAAA;EACT,CAAA;EAEA1B,UAAa,GAAA;IACL,MAAA,IAAItX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAuX,IAAO,GAAA;IACC,MAAA,IAAIvX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAyF,MAAS,GAAA;IACD,MAAA,IAAIzF,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAwX,UAAUH,CAAG,EAAA;IACL,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAyX,SAASJ,CAAG,EAAA;IACVA,CAAA,CAAEjF,QAAQ4G,gBAAgB,CAAA;IAC1B,OAAO3B,CAAE,CAAAnF,OAAA,EAAU,CAAAxL,IAAA,KAAS,eAAiB,EAAA;MAC3C2Q,CAAA,CAAEjF,QAAQuF,gBAAgB,CAAA;IAC5B;IAEAN,CAAA,CAAElF,KAAM,EAAA;IACD,OAAA,IAAA;EACT,CAAA;EAEA0F,UAAUR,CAAG,EAAA;IACXA,CAAA,CAAE7E,aAAc,EAAA;IACT,OAAA,IAAA;EACT,CAAA;EAEAsF,IAAIT,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAiS,IAAIoF,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAU,IAAI2W,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA+X,IAAIV,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAgY,IAAIX,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAiY,IAAIZ,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAkY,IAAIb,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAmF,IAAIkS,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAmY,KAAKd,CAAG,EAAA;IACA,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAoY,SAASf,CAAG,EAAA;IACJ,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEApD,IAAIya,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAsY,QAAQjB,CAAG,EAAA;IACH,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAwY,MAAMnB,CAAG,EAAA;IACD,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAyY,IAAIpB,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA0Y,OAAOrB,CAAG,EAAA;IACF,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA+I,MAAMsO,CAAG,EAAA;IACD,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAoQ,MAAMiH,CAAG,EAAA;IAED,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA6Y,SAAA,CAAUxB,GAAG/E,IAAM,EAAA;IACjB,MAAMrM,IAAO,GAAAkR,YAAA,CAAa0B,SAAU,CAAAxB,CAAA,EAAG/E,IAAI,CAAA;IAC3C,IAAIrM,IAAK,CAAAS,IAAA,KAAS,UAAc,IAAAT,IAAA,CAAKsC,KAAK3K,MAAW,KAAA,CAAA,EAAU,OAAA,IAAA;IAEzD,MAAA,IAAIoC,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAmZ,SAAS9B,CAAG,EAAA;IACJ,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAsZ,KAAKjC,CAAG,EAAA;IACA,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAuZ,IAAIlC,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAwZ,GAAGnC,CAAG,EAAA;IACE,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEAyZ,IAAIpC,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA0Z,IAAIrC,CAAG,EAAA;IACC,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA2Z,KAAKtC,CAAG,EAAA;IACA,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C,CAAA;EAEA4Z,MAAMvC,CAAG,EAAA;IACD,MAAA,IAAIrX,MAAM,yBAAyB,CAAA;EAC3C;AACF,CAAA;AAEA,SAAS8Z,mBAAmBhU,IAAwB,EAAA;EAClD,IAAIA,IAAK,CAAA7I,IAAA,KAAS,iBAAqB,IAAA,CAAC6I,KAAK6B,IAAM,EAAA;IACjD,OAAO7B,IAAK,CAAAY,IAAA;EACd;EAGE,IAAAZ,IAAA,CAAK7I,SAAS,OACd,IAAA6I,IAAA,CAAK7I,SAAS,KACd,IAAA6I,IAAA,CAAK7I,SAAS,YACd,IAAA6I,IAAA,CAAK7I,SAAS,OACd,IAAA6I,IAAA,CAAK7I,SAAS,QACd,IAAA6I,IAAA,CAAK7I,SAAS,eACd,IAAA6I,IAAA,CAAK7I,SAAS,aACd,EAAA;IACO,OAAA6c,kBAAA,CAAmBhU,KAAK6B,IAAI,CAAA;EACrC;EAEA,MAAM,IAAIsP,cAAA,mDAA0DnR,IAAA,CAAK7I,IAAM,EAAA;AACjF;AAEA,SAASic,aAAA,CAAcxS,IAAc,EAAAiH,KAAA,EAA0BL,KAAe,EAAA;EACxE,IAAA,OAAOK,UAAU,QAAU,EAAA;IAC7B,IAAIL,UAAUK,KAAO,EAAA;MACnB,MAAM,IAAIsJ,cAAA,qDACqCvQ,8BAAoBiH,KAAc,mBAAAL,KAAA,OACjF;IACF;aACSK,KAAO,EAAA;IACZ,IAAA,CAACA,KAAM,CAAAL,KAAK,CAAG,EAAA;MACX,MAAA,IAAI2J,cAAe,qDAA6CvQ,IAAS,SAAA;IACjF;EACF;AACF;AAEA,SAASqS,wBAAA,CAAyBD,SAAmB,EAAA0B,YAAA,EAAsBC,QAAkB,EAAA;EACrF,MAAAC,2BAAA,GAA8B,CAAC,YAAA,EAAc,aAAa,CAAA;EAEhE,OAAO5B,aAAa,MAAU,IAAA2B,QAAA,IAAY,CAAK,IAAAC,2BAAA,CAA4BC,SAASH,YAAY,CAAA;AAClG;AAEA,MAAMI,wBAAwB5a,KAAM,CAAA;EAIlCvD,YAAYmW,QAAkB,EAAA;IAC5B,KAAA,kDAAgDA,QAAU,EAAA;IAH5D,IAAA,CAAOlM,IAAO,GAAA,iBAAA;IAIZ,IAAA,CAAKkM,QAAW,GAAAA,QAAA;EAClB;AACF;AAKO,SAASmB,KAAM,CAAA8G,KAAA,EAAqD;EAAA,IAAtC5P,OAAwB,uEAAA,EAAc;EACnE,MAAA1N,MAAA,GAASud,QAASD,KAAK,CAAA;EACzB,IAAAtd,MAAA,CAAON,SAAS,OAAS,EAAA;IACrB,MAAA,IAAI2d,eAAgB,CAAArd,MAAA,CAAOqV,QAAQ,CAAA;EAC3C;EACA,MAAMmI,YAAY,IAAInJ,aAAA,CAAciJ,KAAO,EAAAtd,MAAA,CAAOsU,OAAiB5G,OAAO,CAAA;EACnE,OAAA8P,SAAA,CAAU3I,QAAQ+E,YAAY,CAAA;AACvC;;"}